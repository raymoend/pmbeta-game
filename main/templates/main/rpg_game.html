<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Location RPG - {{ character.name }}</title>
    {% load static %}
    <link rel="icon" href="{% static 'favicon.svg' %}" type="image/svg+xml">
    
    <!-- Mapbox GL JS -->
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    
    <!-- Inject Mapbox token/style from server settings -->
    <script>
      window.MAPBOX_ACCESS_TOKEN = "{{ MAPBOX_ACCESS_TOKEN|default:game_settings.MAPBOX_ACCESS_TOKEN|escapejs }}";
      window.MAPBOX_STYLE = "{{ MAPBOX_STYLE|default:game_settings.MAPBOX_STYLE|default:'mapbox://styles/mapbox/streets-v12'|escapejs }}";
      // Pre-resolved static URLs for NPC markers (hashed in production)
      // Map slugs (from monster template names) to SVG assets. Unknown types use 'default'.
      window.NPC_MARKER_URLS = Object.assign({}, window.NPC_MARKER_URLS || {}, {
        default: "{% static 'img/npc/markers/npc-default.svg' %}",
        // Existing
        'territory-thug': "{% static 'img/npc/markers/territory-thug.svg' %}",
        'territory-guard': "{% static 'img/npc/markers/territory-guard.svg' %}",
        'mafia-enforcer': "{% static 'img/npc/markers/mafia-enforcer.svg' %}",
        // Themed mafia‚Äìalien set
        'yakuza-blade': "{% static 'img/npc/markers/yakuza-blade.svg' %}",
        'cartel-sicario': "{% static 'img/npc/markers/cartel-sicario.svg' %}",
        'void-cultist': "{% static 'img/npc/markers/Void-Cultist.svg' %}",
        'drone-marauder': "{% static 'img/npc/markers/drone-marauder.svg' %}",
        'alien-stalker': "{% static 'img/npc/markers/Alien-Stalker.svg' %}",
        // Classic set
        'forest-wolf': "{% static 'img/npc/markers/forest-wolf.svg' %}",
        'goblin-scout': "{% static 'img/npc/markers/Goblin-Scout.svg' %}",
        'cave-bear': "{% static 'img/npc/markers/Cave-Bear.svg' %}",
        'rabbit': "{% static 'img/npc/markers/Rabbit.svg' %}"
      });
      window.NPC_MARKER_BASE = "{% static 'img/npc/markers/' %}";
      // Resource icons (optional). Fallback to emoji if not found.
      window.RESOURCE_ICON_URLS = {
        'tree': "{% static 'img/resources/tree.svg' %}",
        'berry_bush': "{% static 'img/resources/berry_bush.svg' %}",
        'herb_patch': "{% static 'img/resources/herb_patch.svg' %}",
        'stone_quarry': "{% static 'img/resources/stone_quarry.svg' %}",
        'iron_mine': "{% static 'img/resources/iron_mine.svg' %}",
        'gold_mine': "{% static 'img/resources/gold_mine.svg' %}",
        'ruins': "{% static 'img/resources/ruins.svg' %}",
        'cave': "{% static 'img/resources/cave.svg' %}",
        'well': "{% static 'img/resources/well.svg' %}",
        'farm': "{% static 'img/resources/farm.svg' %}"
      };
      // Key gameplay ranges/timers for gating and labels (server-configured with safe defaults)
      window.GAME_CFG = {
        INTERACTION_RANGE_M: {{ game_settings.INTERACTION_RANGE_M|default:30 }},
        FLAG_INFLUENCE_RADIUS_M: {{ game_settings.FLAG_INFLUENCE_RADIUS_M|default:100 }},
        CLAIM_INFLUENCE_RADIUS_M: {{ game_settings.CLAIM_INFLUENCE_RADIUS_M|default:100 }},
        FLAG_CAPTURE_WINDOW_S: {{ game_settings.FLAG_CAPTURE_WINDOW_S|default:180 }},
        CLAIM_CAPTURE_WINDOW_S: {{ game_settings.CLAIM_CAPTURE_WINDOW_S|default:180 }},
        FLAG_PROTECTION_S: {{ game_settings.FLAG_PROTECTION_S|default:360 }},
        CLAIM_PROTECTION_S: {{ game_settings.CLAIM_PROTECTION_S|default:360 }}
      };
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        /* Main Game Container */
        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Top HUD */
        .game-hud {
            height: 60px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .character-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .character-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .stat-bar {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            font-weight: 500;
            min-width: 30px;
        }
        
        .bar {
            width: 100px;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        
        .hp-bar { background: #e74c3c; }
        .mana-bar { background: #3498db; }
        .stamina-bar { background: #f39c12; }
        .xp-bar { background: #8e44ad; }
        
        .level-gold {
            margin-left: auto;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .level-display {
            background: rgba(0,0,0,0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .gold-display {
            background: #f39c12;
            color: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .settings-btn {
            background: rgba(0,0,0,0.2);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        
        .settings-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        
        /* Main Game Area */
        .game-main {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        /* Mapbox Container */
        #map {
            flex: 1;
            height: 100%;
            position: relative;
        }
        
        /* Vignette overlay for PK feel */
        .vignette {
            pointer-events: none;
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.25) 100%);
            z-index: 50;
        }
        
        /* Side Panel */
        .side-panel {
            width: 300px;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            z-index: 500;
        }
        
        .panel-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
        }
        
        .tab-button {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            color: #bdc3c7;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .tab-button.active {
            background: #3498db;
            color: #fff;
        }
        
        .tab-button:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .tab-panel {
            display: none;
        }
        
        .tab-panel.active {
            display: block;
        }
        
        /* Inventory Styles */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .inventory-slot:hover {
            border-color: #3498db;
            transform: translateY(-2px);
        }
        
        .inventory-slot.equipped {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }
        
        .item-icon {
            width: 32px;
            height: 32px;
            background: #95a5a6;
            border-radius: 4px;
        }
        
        .item-quantity {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: #e74c3c;
            color: #fff;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }
        
        /* Character Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-item {
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .stat-name {
            font-size: 0.9rem;
            color: #bdc3c7;
            margin-top: 4px;
        }
        
        /* Nearby Players */
        .nearby-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .nearby-player {
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
        }
        
        .player-name {
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .player-level {
            font-size: 0.8rem;
            color: #95a5a6;
        }
        
        .player-distance {
            font-size: 0.8rem;
            color: #3498db;
        }
        
        .action-buttons {
            display: flex;
            gap: 5px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .btn-combat {
            background: #e74c3c;
            color: #fff;
        }
        
        .btn-trade {
            background: #f39c12;
            color: #fff;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* Combat Modal */
        .combat-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .combat-container {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .combat-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #e74c3c;
        }
        
        .combat-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }
        
        .combatant {
            flex: 1;
            padding: 0 20px;
        }
        
        .combatant-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .vs-separator {
            align-self: center;
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
        }
        
        .combat-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .btn-large {
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 8px;
        }
        
        .btn-attack {
            background: #e74c3c;
            color: #fff;
        }
        
        .btn-defend {
            background: #95a5a6;
            color: #fff;
        }
        
        .btn-flee {
            background: #7f8c8d;
            color: #fff;
        }
        
        /* Messages */
        .message-area {
            position: fixed;
            top: 70px;
            right: 20px;
            max-width: 300px;
            z-index: 1500;
        }
        
        .message {
            background: rgba(52, 152, 219, 0.9);
            color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
        }
        
        .message.error {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .message.success {
            background: rgba(46, 204, 113, 0.9);
        }
        /* Chat overlay */
        .chat-overlay {
            position: fixed;
            left: 12px;
            bottom: 12px;
            width: 340px;
            max-width: calc(100vw - 24px);
            background: rgba(17, 24, 39, 0.9);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            z-index: 1800;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(31, 41, 55, 0.95);
            color: #e5e7eb;
            font-weight: 700;
            font-size: 0.9rem;
        }
        .chat-body {
            height: 180px;
            overflow-y: auto;
            padding: 8px 10px;
        }
        .chat-msg { font-size: 0.85rem; color: #e5e7eb; margin-bottom: 6px; }
        .chat-meta { color: #9ca3af; font-size: 0.75rem; margin-right: 6px; }
        .chat-input {
            display: flex;
            gap: 6px;
            padding: 8px;
            border-top: 1px solid rgba(255,255,255,0.08);
            background: rgba(31,41,55,0.95);
        }
        .chat-input input[type="text"] {
            flex: 1;
            background: rgba(55,65,81,0.6);
            color: #e5e7eb;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            padding: 8px 10px;
        }
        .chat-input select, .chat-input button {
            background: rgba(55,65,81,0.6);
            color: #e5e7eb;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            padding: 8px 10px;
            cursor: pointer;
        }
        .chat-min { cursor: pointer; color: #9ca3af; }
        
        /* Item drop animation */
        .item-drop {
            position: absolute;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(17,24,39,0.85);
            border: 1px solid rgba(255,255,255,0.12);
            padding: 6px 8px;
            border-radius: 8px;
            color: #e5e7eb;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            animation: dropFade 1.2s ease-out forwards;
            z-index: 1600;
        }
        .item-drop img { width: 18px; height: 18px; }
        .item-drop .item-quantity { font-weight: 700; }
        @keyframes dropFade {
            0% { transform: translateY(0) scale(0.95); opacity: 0; }
            20% { opacity: 1; }
            80% { transform: translateY(-24px) scale(1.02); opacity: 1; }
            100% { transform: translateY(-28px) scale(0.98); opacity: 0; }
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Enhanced NPC Popup Styles */
        .npc-popup {
            font-family: 'Segoe UI', sans-serif;
            color: #333;
            min-width: 250px;
        }
        
        .npc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
        }
        
        .npc-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .npc-level {
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .npc-stats {
            margin: 10px 0;
        }
        
        .npc-hp {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .hp-label {
            font-weight: bold;
            font-size: 0.9rem;
            color: #555;
        }
        
        .hp-bar-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .hp-bar-bg {
            flex: 1;
            height: 12px;
            background: #ecf0f1;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
        }
        
        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .hp-text {
            font-size: 0.8rem;
            font-weight: bold;
            color: #555;
            min-width: 50px;
        }
        
        .npc-distance {
            font-size: 0.8rem;
            color: #7f8c8d;
            text-align: center;
        }
        
        .npc-actions {
            margin-top: 12px;
            text-align: center;
        }
        
        .fight-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 0.9rem;
        }
        
        .fight-btn:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .fight-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .fight-btn.disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .fight-btn.disabled:hover {
            background: #95a5a6;
            transform: none;
            box-shadow: none;
        }
        
        /* Victory Popup */
        .victory-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }
        .victory-card {
            background: linear-gradient(135deg, #1f2937, #111827);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 22px 20px;
            width: 92%;
            max-width: 460px;
            color: #e5e7eb;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        .victory-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #22c55e;
            text-align: center;
            margin-bottom: 6px;
        }
        .victory-sub {
            text-align: center;
            color: #9ca3af;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }
        .drops-list {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 10px 12px;
            margin-top: 10px;
        }
        .drop-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed rgba(255,255,255,0.07);
        }
        .drop-item:last-child { border-bottom: none; }
        .victory-actions {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }
        .victory-actions .btn {
            flex: 1;
            padding: 10px 12px;
            border-radius: 8px;
            font-weight: 600;
        }
        .btn-close-victory { background: #2563eb; color: #fff; }
        .btn-inventory { background: #4b5563; color: #fff; }
        
        /* Responsive */
        @media (max-width: 768px) {
            .side-panel {
                position: absolute;
                right: -300px;
                top: 0;
                height: 100%;
                transition: right 0.3s ease;
                z-index: 1000;
            }
            
            .side-panel.open {
                right: 0;
            }
            
            .mobile-menu-toggle {
                position: absolute;
                top: 10px;
                right: 10px;
                background: #3498db;
                color: #fff;
                border: none;
                padding: 10px;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1100;
            }
            
            .character-info {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .stat-bar {
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Hidden CSRF token for fetch() calls -->
    <form style="display:none;">{% csrf_token %}</form>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
    </div>

    <div class="game-container">
        <!-- Top HUD -->
        <div class="game-hud">
            <div class="character-info">
                <div class="character-name">{{ character.name }}</div>
                
                <div class="stat-bar">
                    <span class="stat-label">HP</span>
                    <div class="bar">
                        <div class="bar-fill hp-bar" style="width: {{ character.current_hp|floatformat:0 }}%"></div>
                    </div>
                    <span>{{ character.current_hp }}/{{ character.max_hp }}</span>
                </div>
                
                <div class="stat-bar">
                    <span class="stat-label">MP</span>
                    <div class="bar">
                        <div class="bar-fill mana-bar" style="width: {{ character.current_mana|floatformat:0 }}%"></div>
                    </div>
                    <span>{{ character.current_mana }}/{{ character.max_mana }}</span>
                </div>
                
                <div class="stat-bar">
                    <span class="stat-label">ST</span>
                    <div class="bar">
                        <div class="bar-fill stamina-bar" style="width: {{ character.current_stamina|floatformat:0 }}%"></div>
                    </div>
                    <span>{{ character.current_stamina }}/{{ character.max_stamina }}</span>
                </div>
                
                <div class="stat-bar">
                    <span class="stat-label">XP</span>
                    <div class="bar">
                        <div class="bar-fill xp-bar" id="xpBar" style="width: 0%"></div>
                    </div>
                    <span id="xpText">0/0</span>
                </div>
            </div>
            
            <div class="level-gold">
                <div class="level-display">Level {{ character.level }}</div>
                <div class="gold-display">{{ character.gold|floatformat:0 }}g</div>
                <button class="settings-btn" id="settingsBtn" onclick="openSettingsModal()" title="Settings">
                    ‚öôÔ∏è
                </button>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-main">
            <!-- Mapbox Map -->
            <div id="map"></div>
            
            <!-- Mobile Menu Toggle -->
            <button class="mobile-menu-toggle" onclick="toggleSidePanel()" style="display: none;">‚ò∞</button>
            
            <!-- Side Panel -->
            <div class="side-panel" id="sidePanel">
                <div class="panel-tabs">
                    <button class="tab-button active" onclick="showTab('inventory', this)">Inventory</button>
                    <button class="tab-button" onclick="showTab('character', this)">Character</button>
                    <button class="tab-button" onclick="showTab('nearby', this)">Players</button>
                    <button class="tab-button" onclick="showTab('log', this)">Log</button>
                    <button class="tab-button" onclick="showTab('flags', this)">Flags</button>
                    <button class="tab-button" onclick="showTab('resources', this)">Resources</button>
                    <button class="tab-button" onclick="showTab('crafting', this)">Crafting</button>
                </div>
                
                <div class="panel-content">
                    <!-- Inventory Tab -->
                    <div id="inventory-tab" class="tab-panel active">
                        <h3>Inventory</h3>
                        <div style="display:flex; gap:8px; margin:8px 0 12px;">
                            <button id="heal-berries-btn" class="btn" style="background:#22c55e;color:white;" onclick="healWithBerries()">üçì Heal with berries</button>
                        </div>
                        <div class="inventory-grid" id="inventoryGrid">
                            <!-- Inventory slots will be populated by JavaScript -->
                        </div>
                        
                        <h4>Equipment</h4>
                        <div class="inventory-grid">
                            <div class="inventory-slot" data-slot="weapon">
                                <div class="item-icon"></div>
                            </div>
                            <div class="inventory-slot" data-slot="armor">
                                <div class="item-icon"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Character Tab -->
                    <div id="character-tab" class="tab-panel">
                        <h3>Character Stats</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value">{{ character.strength }}</div>
                                <div class="stat-name">Strength</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">{{ character.defense }}</div>
                                <div class="stat-name">Defense</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">{{ character.vitality }}</div>
                                <div class="stat-name">Vitality</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">{{ character.agility }}</div>
                                <div class="stat-name">Agility</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">{{ character.intelligence }}</div>
                                <div class="stat-name">Intelligence</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value">{{ character.experience }}</div>
                                <div class="stat-name">Experience</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Nearby Players Tab -->
                    <div id="nearby-tab" class="tab-panel">
                        <h3>Nearby Players</h3>
                        <div class="nearby-list" id="nearbyPlayersList">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Log Tab -->
                    <div id="log-tab" class="tab-panel">
                        <h3>Combat Log</h3>
                        <div id="combatLogList" style="max-height: 300px; overflow-y: auto; font-size: 0.9rem; color: #e5e7eb;"></div>
                    </div>

                    <!-- Flags Tab -->
                    <div id="flags-tab" class="tab-panel">
                        <h3>Flags</h3>
                        <div style="display:flex; gap:8px; margin:8px 0 12px;">
                            <button class="btn" style="background:#10b981;color:white;" onclick="uiPlaceFlagAtCenter()">Place at map center</button>
                            <button class="btn" style="background:#3b82f6;color:white;" onclick="uiPlaceFlagAtPlayer()">Place at player</button>
                        </div>
                        <div id="flagsList" style="display: grid; grid-template-columns: 1fr; gap: 8px; max-height: 340px; overflow-y: auto;"></div>
                    </div>

                    <!-- Resources Tab -->
                    <div id="resources-tab" class="tab-panel">
                        <h3>Resources</h3>
                        <div id="resourcesList" style="display: grid; grid-template-columns: 1fr; gap: 8px; max-height: 340px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Crafting Tab -->
                    <div id="crafting-tab" class="tab-panel">
                        <h3>üî® Crafting</h3>
                        <div style="margin-bottom: 15px; text-align: center;">
                            <a href="/crafting/" target="_blank" class="btn" style="background: linear-gradient(45deg, #f39c12, #e67e22); color: white; text-decoration: none; padding: 10px 20px; border-radius: 5px; display: inline-block;">
                                Open Crafting Workshop
                            </a>
                        </div>
                        <div id="craftingQuickPanel" style="max-height: 400px; overflow-y: auto;">
                            <div style="text-align: center; color: #95a5a6; padding: 20px;">
                                Loading crafting info...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Combat Modal -->
    <div class="combat-modal" id="combatModal">
        <div class="combat-container">
            <div class="combat-title">Combat!</div>
            <div class="combat-stats">
                <div class="combatant">
                    <div class="combatant-name" id="playerName">{{ character.name }}</div>
                    <div class="bar">
                        <div class="bar-fill hp-bar" id="playerHpBar"></div>
                    </div>
                    <div id="playerHp"></div>
                </div>
                <div class="vs-separator">VS</div>
                <div class="combatant">
                    <div class="combatant-name" id="enemyName"></div>
                    <div class="bar">
                        <div class="bar-fill hp-bar" id="enemyHpBar"></div>
                    </div>
                    <div id="enemyHp"></div>
                </div>
            </div>
            <div class="combat-actions">
                <button class="btn btn-large btn-attack" onclick="combatAction('attack')">Attack</button>
                <button class="btn btn-large btn-defend" onclick="combatAction('defend')">Defend</button>
                <button class="btn btn-large btn-flee" onclick="combatAction('flee')">Flee</button>
            </div>
        </div>
    </div>

    <!-- Message Area -->
    <div class="message-area" id="messageArea"></div>

    <!-- Chat Overlay -->
    <div class="chat-overlay" id="chatOverlay" aria-live="polite">
        <div class="chat-header">
            <div>Chat</div>
            <div class="chat-min" onclick="toggleChat()">_</div>
        </div>
        <div class="chat-body" id="chatMessages"></div>
        <div class="chat-input">
            <select id="chatChannelSelect" title="Channel">
                <option value="location">Local</option>
                <option value="global">Global</option>
            </select>
            <input type="text" id="chatInput" placeholder="Type a message and press Enter" maxlength="200" />
            <button onclick="sendChat()">Send</button>
        </div>
    </div>
    {% if messages %}
    <script>
      window.addEventListener('load', function() {
        try {
          {% for message in messages %}
            if (typeof showMessage === 'function') { showMessage("{{ message|escapejs }}", "{{ message.tags|default:'info' }}"); }
          {% endfor %}
        } catch(e) {}
      });
    </script>
    {% endif %}

    <!-- Settings Modal -->
    <div class="combat-modal" id="settingsModal" style="display: none;">
        <div class="combat-container" style="max-width: 400px;">
            <div class="combat-title">‚öôÔ∏è Settings</div>
            <div style="text-align: left; margin: 20px 0;">
                <button class="btn btn-large" onclick="openRelocateModal()" style="width: 100%; margin-bottom: 10px; background: #3498db; color: white;">
                    üìç Relocate GPS
                </button>
                <button class="btn btn-large" onclick="resetMapClient()" style="width: 100%; margin-bottom: 10px; background: #6b7280; color: white;">
                    üßπ Clear map (client)
                </button>
                <button class="btn btn-large" onclick="logout()" style="width: 100%; background: #e74c3c; color: white;">
                    üö™ Logout
                </button>
            </div>
            <div style="text-align: center;">
                <button class="btn btn-large btn-defend" onclick="closeSettingsModal()" style="background: #95a5a6;">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- GPS Relocate Modal -->
    <div class="combat-modal" id="relocateModal" style="display: none;">
        <div class="combat-container" style="max-width: 450px;">
            <div class="combat-title">üìç GPS Relocation</div>
            <div style="text-align: left; margin: 20px 0;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Current Location:</label>
                    <div style="color: #bdc3c7; font-size: 0.9rem;" id="currentLocationDisplay">
                        {{ character.lat|floatformat:6 }}, {{ character.lon|floatformat:6 }}
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label for="newLatitude" style="display: block; margin-bottom: 5px; font-weight: bold;">Latitude:</label>
                    <input type="number" id="newLatitude" step="0.000001" min="-90" max="90" 
                           value="{{ character.lat|floatformat:6 }}"
                           style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #ecf0f1; color: #2c3e50;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label for="newLongitude" style="display: block; margin-bottom: 5px; font-weight: bold;">Longitude:</label>
                    <input type="number" id="newLongitude" step="0.000001" min="-180" max="180" 
                           value="{{ character.lon|floatformat:6 }}"
                           style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #bdc3c7; background: #ecf0f1; color: #2c3e50;">
                </div>
                <div style="font-size: 0.8rem; color: #f39c12; margin-bottom: 15px;">
                    ‚ö†Ô∏è Warning: This will instantly teleport your character to the specified coordinates!
                </div>
            </div>
            <div style="text-align: center; display: flex; gap: 10px;">
                <button class="btn btn-large btn-defend" onclick="closeRelocateModal()" style="flex: 1; background: #95a5a6;">
                    Cancel
                </button>
                <button class="btn btn-large btn-attack" onclick="performRelocate()" style="flex: 1; background: #e67e22;">
                    üöÄ Teleport
                </button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            character: {
                name: '{{ character.name }}',
                level: {{ character.level }},
                lat: {{ character.lat }},
                lon: {{ character.lon }},
                current_hp: {{ character.current_hp }},
                max_hp: {{ character.max_hp }},
                current_mana: {{ character.current_mana }},
                max_mana: {{ character.max_mana }},
                current_stamina: {{ character.current_stamina }},
                max_stamina: {{ character.max_stamina }},
                gold: {{ character.gold }},
                strength: {{ character.strength }},
                defense: {{ character.defense }},
                vitality: {{ character.vitality }},
                agility: {{ character.agility }},
                intelligence: {{ character.intelligence }}
            },
            map: null,
            websocket: null,
            nearbyPlayers: [],
            monsters: [],
            resources: [],
            activeCombat: null,
            flags: [],
            flagMarkers: {},
            resourceMarkers: {},
            resourceTicker: null,
            hexOrigin: null, // { x, y } in Web Mercator meters for stable lattice anchoring
            autoCombatTimer: null,
            autoCombatBusy: false,
            hpTickerEl: null,
            combatLog: []
        };
        const CURRENT_USER_ID = {{ request.user.id|default:'null' }};
        // Style fallback guard to recover from invalid style IDs in production
        let styleFallbackApplied = false;
        // Path to flag icon (SVG). Place your file at this path, or update the URL accordingly.
        const FLAG_GIF_URL = '/static/img/flag_green.svg';

        // Sanitize Mapbox style: only allow known-good styles and correct common invalids
        function sanitizeMapboxStyle(userStyle) {
            try {
                const def = 'mapbox://styles/mapbox/streets-v12';
                if (!userStyle || typeof userStyle !== 'string') return def;
                const s = userStyle.trim();
                if (!/^mapbox:\/\//.test(s)) return def;
                const allowed = [
                    'mapbox://styles/mapbox/streets-v12',
                    'mapbox://styles/mapbox/dark-v11',
                    'mapbox://styles/mapbox/light-v11',
                    'mapbox://styles/mapbox/outdoors-v12',
                    'mapbox://styles/mapbox/satellite-streets-v12'
                ];
                if (allowed.includes(s)) return s;
                // Fix common invalid versions by mapping to nearest supported
                if (s.indexOf('light-v12') !== -1) return 'mapbox://styles/mapbox/light-v11';
                if (s.indexOf('streets-v13') !== -1) return 'mapbox://styles/mapbox/streets-v12';
                return def;
            } catch (_) {
                return 'mapbox://styles/mapbox/streets-v12';
            }
        }

        // Initialize Mapbox
        mapboxgl.accessToken = (typeof window !== 'undefined' && window.MAPBOX_ACCESS_TOKEN) ? window.MAPBOX_ACCESS_TOKEN : '{{ game_settings.MAPBOX_ACCESS_TOKEN|escapejs }}';
        if (!mapboxgl.accessToken) { console.error('Missing MAPBOX_ACCESS_TOKEN'); }

        // Flags now use Django API under /api/flags/

        function initializeMap() {
            // Basic guard: ensure Mapbox GL loaded
            if (typeof mapboxgl === 'undefined') {
                console.error('Mapbox GL JS failed to load');
                showMessage('Map failed to load (Mapbox script). Check your network or ad-blockers.', 'error');
                const ls = document.getElementById('loadingScreen');
                if (ls) ls.style.display = 'none';
                return;
            }
            if (!mapboxgl.accessToken) {
                console.error('Missing MAPBOX_ACCESS_TOKEN');
                showMessage('Missing Mapbox token. Please configure MAPBOX_ACCESS_TOKEN.', 'error');
            }

            // Choose a safe style up-front to avoid initial 404s from invalid styles (e.g., light-v12)
            // Allow URL override for style testing: /game/?style=mapbox://styles/mapbox/streets-v12
            let styleCandidate = null;
            try { styleCandidate = new URLSearchParams(window.location.search).get('style') || null; } catch (_) { styleCandidate = null; }
            if (!styleCandidate) {
                styleCandidate = (typeof window !== 'undefined' && window.MAPBOX_STYLE) ? window.MAPBOX_STYLE : '{{ game_settings.MAPBOX_STYLE|default:"mapbox://styles/mapbox/streets-v12"|escapejs }}';
            }
            const safeStyle = sanitizeMapboxStyle(styleCandidate);
            try { window.__mapbox_debug = { token_present: !!(mapboxgl.accessToken && mapboxgl.accessToken.length > 40), style_candidate: styleCandidate, style_used: safeStyle }; } catch(_) {}

            gameState.map = new mapboxgl.Map({
                container: 'map',
                style: safeStyle,
                center: [gameState.character.lon, gameState.character.lat],
                zoom: 17.5, // initial zoom
                minZoom: 16,
                maxZoom: 17.5,
                pitch: 0,
                bearing: 0,
                interactive: true, // Enable interactions for tap-to-move
                scrollZoom: true, // allow scroll zoom within bounds
                boxZoom: false, // Disable box zoom
                dragRotate: false, // Disable rotation
                touchZoomRotate: true, // allow pinch zoom
                doubleClickZoom: false, // Disable double-click zoom
                keyboard: true // Allow +/- key zoom within bounds
            });

            // Surface Mapbox runtime errors with clearer diagnostics
            gameState.map.on('error', function(e) {
                const err = e && e.error ? e.error : e;
                const status = (err && err.status) ? err.status : 0;
                const url = (err && (err.url || err.resource || '')) || '';
                try { console.warn('Mapbox request failed', { status, url, message: err && err.message }); } catch (_) {}
                // If the configured style 404s, recover by switching to a known-good style once
                if (!styleFallbackApplied && status === 404 && typeof url === 'string' && url.indexOf('/styles/v1/') !== -1) {
                    console.warn('Map style 404 ‚Äì falling back to mapbox://styles/mapbox/streets-v12');
                    styleFallbackApplied = true;
                    try { gameState.map.setStyle('mapbox://styles/mapbox/streets-v12'); } catch (ex) {}
                    return;
                }
                // Token/auth issues
                if (status === 401 || status === 403 || (err && /unauth|forbidden/i.test(String(err.message || '')))) {
                    showMessage('Mapbox auth error: check MAPBOX_ACCESS_TOKEN.', 'error');
                    const ls = document.getElementById('loadingScreen');
                    if (ls) ls.style.display = 'none';
                    return;
                }
                // Sprite/glyph asset 404s: warn but do not block map
                if (status === 404 && typeof url === 'string' && (url.indexOf('/sprites/') !== -1 || url.indexOf('/glyphs/') !== -1)) {
                    console.warn('Map asset 404 (sprite/glyph). Rendering may be degraded.');
                    return;
                }
                console.error('Mapbox error:', err);
                showMessage('Map error: ' + (err && err.message ? err.message : 'See console'), 'error');
                const ls = document.getElementById('loadingScreen');
                if (ls) ls.style.display = 'none';
            });

            gameState.map.on('load', function() {
                // Add player marker
                addPlayerMarker();

                // Draw hex grid and keep it updated
                drawHexGrid();
                gameState.map.on('moveend', drawHexGrid);

                // Load initial game data
                loadGameData();

                // Add movement radius ring (800m) around player
                try {
                    const radiusMeters = 800;
                    const poly = circlePolygon(gameState.character.lon, gameState.character.lat, radiusMeters, 90);
                    if (!gameState.map.getSource('move-radius')) {
                        gameState.map.addSource('move-radius', { type: 'geojson', data: { type: 'Feature', geometry: poly } });
                    } else {
                        gameState.map.getSource('move-radius').setData({ type: 'Feature', geometry: poly });
                    }
                    if (!gameState.map.getLayer('move-radius-fill')) {
                        gameState.map.addLayer({
                            id: 'move-radius-fill',
                            type: 'fill',
                            source: 'move-radius',
                            paint: {
                                'fill-color': '#3b82f6',
                                'fill-opacity': 0.07,
                                'fill-outline-color': '#60a5fa'
                            }
                        });
                    }
                } catch (e) { console.warn('move-radius add failed', e); }
                
                // Hide loading screen
                document.getElementById('loadingScreen').style.display = 'none';
                
                // Add zoom controls (compass hidden)
                try { gameState.map.addControl(new mapboxgl.NavigationControl({ showCompass: false })); } catch(e) {}
                
                // Initialize WebSocket
                initializeWebSocket();
                
                // Start game loop
                startGameLoop();

                // Start resource cooldown ticker (client-side)
                try { startResourceTicker(); } catch (e) { console.warn('resource ticker init failed', e); }
                
                // Add tap-to-move functionality
                initializeTapToMove();

                // Ensure map resizes on layout changes
                try { if (gameState.map && gameState.map.resize) gameState.map.resize(); } catch(e) {}
                setTimeout(() => { try { if (gameState.map && gameState.map.resize) gameState.map.resize(); } catch(e) {} }, 150);
            });

            // Safety: hide loading after timeout if map never loads
            setTimeout(() => {
                const ls = document.getElementById('loadingScreen');
                if (ls && ls.style.display !== 'none') {
                    console.warn('Map load timeout; hiding loading overlay.');
                    ls.style.display = 'none';
                }
            }, 5000);

            // Resize handler
            window.addEventListener('resize', () => { try { if (gameState.map && gameState.map.resize) gameState.map.resize(); } catch(e) {} });
        }

        function addPlayerMarker() {
            // Add player location marker
            const playerMarker = new mapboxgl.Marker({
                color: '#3498db',
                scale: 1.2
            })
            .setLngLat([gameState.character.lon, gameState.character.lat])
            .addTo(gameState.map);
        }

        // --- Main draw function ---
        function drawHexGrid() {
            if (!gameState.map) return;
            const bounds = gameState.map.getBounds();

            // Convert bounds to Web Mercator meters
            const [minX, minY] = project(bounds.getWest(), bounds.getSouth());
            const [maxX, maxY] = project(bounds.getEast(), bounds.getNorth());

            const features = [];

            // Hex dimensions (flat-topped)
            const r = 650;                 // hex radius in meters
            const w = 2 * r;               // width
            const h = Math.sqrt(3) * r;    // height
            const xStep = 1.5 * r;         // correct column step (equals 0.75 * w)
            const yStep = h;               // correct row step

            // Use a global lattice origin (0,0) in Web Mercator meters so client matches server hex IDs
            const originX = 0;
            const originY = 0;

            // Compute starting X aligned to global lattice that still covers current bounds
            const startX = Math.floor((minX - originX) / xStep) * xStep + originX;

            // Iterate columns first; stagger odd columns by h/2 for flat-top hexes
            for (let x = startX; x <= maxX + xStep; x += xStep) {
                const col = Math.floor(((x - originX) + xStep/2) / xStep);
                // For each column, compute a base Y that ensures coverage even with stagger offset
                const yOffset = (col % 2 ? h / 2 : 0);
                const startYForCol = Math.floor((minY - originY - yOffset) / yStep) * yStep + originY;
                for (let y = startYForCol; y <= maxY + yStep; y += yStep) {
                    const cx = x;
                    const cy = y + yOffset;

                    // Quick cull outside current bounds (with small buffer)
                    if (cx < minX - xStep || cx > maxX + xStep || cy < minY - yStep || cy > maxY + yStep) continue;

                    // Build circle polygon to avoid white seams between hexes
                    const [lonC, latC] = unproject(cx, cy);
                    const rCircle = r * 1.02; // slight growth to ensure overlap
                    const circleGeom = circlePolygon(lonC, latC, rCircle, 60);

                    const row = Math.round((y - originY) / yStep);
                    const q = col;
                    const rAxial = row - ((q - (q & 1)) / 2);
                    features.push({
                        type: 'Feature',
                        geometry: circleGeom,
                        properties: { q: q, r: rAxial }
                    });
                }
            }

            // Update or add source
            if (!gameState.map.getSource('grid')) {
                gameState.map.addSource('grid', {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features }
                });
            } else {
                gameState.map.getSource('grid').setData({
                    type: 'FeatureCollection',
                    features
                });
            }

            // Add or update layer
            if (!gameState.map.getLayer('grid-hex')) {
                gameState.map.addLayer({
                    id: 'grid-hex',
                    type: 'fill',
                    source: 'grid',
                    paint: {
                        'fill-color': '#6b6b6b',
                        'fill-opacity': 0.0,
                        'fill-antialias': false
                    }
                });
            } else {
                try {
                    gameState.map.setPaintProperty('grid-hex', 'fill-opacity', 0.0);
                    gameState.map.setPaintProperty('grid-hex', 'fill-antialias', false);
                } catch (e) { /* no-op */ }
            }
            // Keep the hex grid UNDER territory layers for correct visual stacking
            try {
                if (gameState.map.getLayer('territories_fill')) {
                    gameState.map.moveLayer('grid-hex', 'territories_fill');
                }
            } catch (e) { /* safe no-op */ }

            // Add or update grid outline lines to show lattice without fills (prevents seam triangles)
            if (!gameState.map.getLayer('grid-hex-outline')) {
                gameState.map.addLayer({
                    id: 'grid-hex-outline',
                    type: 'line',
                    source: 'grid',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: {
                        'line-color': '#6b6b6b',
                        'line-opacity': ['interpolate', ['linear'], ['zoom'], 12, 0.12, 16, 0.06],
                        'line-width': ['interpolate', ['linear'], ['zoom'], 12, 0.4, 16, 0.7],
                        'line-blur': 0.2
                    }
                });
            }
            // Ensure outline sits beneath territories as well
            try {
                if (gameState.map.getLayer('territories_fill')) {
                    gameState.map.moveLayer('grid-hex-outline', 'territories_fill');
                }
            } catch (e) { /* safe no-op */ }
        }

        function loadGameData() {
            // Load nearby players
            fetchNearbyPlayers();
            
            // Load monsters
            fetchNearbyMonsters();

            // Load resources
            fetchNearbyResources();
            
            // Load inventory
            loadInventory();
            
            // Load existing flags
            fetchNearbyFlags();
        }

        function fetchNearbyPlayers() {
            fetch('/api/rpg/nearby-players/')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateNearbyPlayers(data.players);
                    }
                })
                .catch(error => console.error('Error fetching nearby players:', error));
        }

        function fetchNearbyMonsters() {
            fetch('/api/rpg/nearby-monsters/')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateMonsters(data.monsters);
                    }
                })
                .catch(error => console.error('Error fetching monsters:', error));
        }

        function fetchNearbyResources() {
            fetch('/api/resources/nearby/?radius=1000', { credentials: 'same-origin' })
                .then(r => r.json())
                .then(data => {
                    if (!data || data.success === false) return;
                    const resources = Array.isArray(data.resources) ? data.resources : [];
                    gameState.resources = resources;
                    try { updateResourceMarkers(resources); } catch(_) {}
                    try { renderResourcesList(resources); } catch(_) {}
                })
                .catch(err => console.warn('Error fetching resources', err));
        }
        
        function fetchNearbyFlags() {
            const csrf = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
            const opts = { method: 'GET', headers: { 'X-CSRFToken': csrf }, credentials: 'same-origin' };
            // Directly call the working endpoint to avoid 404 noise
            const lat = gameState?.character?.lat;
            const lon = gameState?.character?.lon;
            const q = (typeof lat === 'number' && typeof lon === 'number') ? `?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&radius_m=2000` : '';
            fetch(`/api/flags/near/${q}`, opts)
              .then(res => {
                if (!res.ok) throw new Error('Flags request failed: ' + res.status);
                return res.json();
              })
              .then(data => {
                if (!data || data.success === false) {
                  console.warn('Flag API error:', data?.error);
                  return;
                }
                const flags = (data.data && (data.data.flags || data.data)) || [];
                // Normalize to frontend shape
                const normalized = flags.map(f => ({
                    id: String(f.id),
                    name: f.name || `Flag`,
                    lat: f.lat,
                    lon: f.lon,
                    level: f.level || 1,
                    owner_id: f.owner_id,
                    is_mine: f.owner_id === CURRENT_USER_ID,
                    status: f.status || 'active',
                    is_private: !!f.is_private,
                    color: f.color || null,
                    distance_m: typeof f.distance_m === 'number' ? f.distance_m : Math.round(calculateDistance(gameState.character.lat, gameState.character.lon, f.lat, f.lon))
                }));
                gameState.flags = normalized;
                // Fetch detailed timers for nearest flags (up to 10)
                try { fetchFlagDetails(normalized.slice(0, 10).map(x => x.id)); } catch(_) {}

                // Reconcile markers: remove missing, update existing, add new
                const currentIds = new Set(normalized.map(f => f.id));
                // Remove markers that are no longer present
                Object.keys(gameState.flagMarkers || {}).forEach(id => {
                    if (!currentIds.has(id)) {
                        try { gameState.flagMarkers[id].remove(); } catch(e) {}
                        delete gameState.flagMarkers[id];
                    }
                });
                // Add or update markers
                normalized.forEach(flag => {
                    const existing = gameState.flagMarkers[flag.id];
                    if (existing) {
                        try { existing.setLngLat([flag.lon, flag.lat]); } catch(e) {}
                    } else {
                        addFlagToMap(flag);
                    }
                });

                const terrFill = 'territories_fill';
                const terrGlow = 'territories_glow';
                const terrBorder = 'territories_border';
                // Also build hex outlines for clarity
                const terrSrcId = 'territories_source';
                const hexData = buildHexGeo(gameState.flags);
                const unionedHexData = dissolveHexesByOwner(hexData);
                if (!gameState.map.getSource(terrSrcId)) {
                    gameState.map.addSource(terrSrcId, { type: 'geojson', data: unionedHexData });
                } else {
                    gameState.map.getSource(terrSrcId).setData(unionedHexData);
                }
                // Update presence state based on latest flags
                checkTerritoryPresence();
                try { renderFlagsList(); } catch (e) {}
                try { startFlagTicker(); } catch (e) {}

                if (!gameState.map.getLayer(terrFill)) {
                    // Use hex polygons for seamless connected territories
                    gameState.map.addLayer({
                        id: terrFill,
                        type: 'fill',
                        source: terrSrcId,
                        paint: {
'fill-color': ['case',
                                ['all', ['has','color'], ['!=', ['get','color'], '']], ['get','color'],
                                ['==', ['get','status'], 'capturable'], '#f1c40f',
                                ['==', ['get','owner_id'], CURRENT_USER_ID], '#2ecc71',
                                '#e74c3c'
                            ],
                            'fill-opacity': 0.25,
                            'fill-antialias': true
                        },
                        minzoom: 10
                    });
                } else {
                    // Ensure the fill uses the hex source
                    try { gameState.map.getLayer(terrFill) && gameState.map.moveLayer(terrFill); } catch(e) {}
                }
                // Ensure grid layer stays beneath territories
                try { if (gameState.map.getLayer('grid-hex')) gameState.map.moveLayer('grid-hex', terrFill); } catch (e) {}
                // Owner-colored glowing borders like PK, using hex polygons.
                if (!gameState.map.getLayer(terrBorder)) {
                    gameState.map.addLayer({
                        id: terrBorder,
                        type: 'line',
                        source: terrSrcId,
                        layout: { 'line-join': 'round', 'line-cap': 'round' },
                        paint: {
'line-color': ['case',
                                ['all', ['has','color'], ['!=', ['get','color'], '']], ['get','color'],
                                ['==', ['get','status'], 'capturable'], '#f1c40f',
                                ['==', ['get','owner_id'], CURRENT_USER_ID], '#2ecc71',
                                '#e74c3c'
                            ],
                            'line-width': ['interpolate', ['linear'], ['zoom'], 10, 1.5, 15, 3],
                            'line-blur': 0.5,
                            'line-opacity': 0.9
                        },
                        minzoom: 10
                    });
                }
                // Subtle outer glow line for extra pop, using hex polygons.
                if (!gameState.map.getLayer(terrGlow)) {
                    gameState.map.addLayer({
                        id: terrGlow,
                        type: 'line',
                        source: terrSrcId,
                        paint: {
                            'line-color': ['case',
                                ['==', ['get','status'], 'capturable'], '#f39c12',
                                ['==', ['get','owner_id'], CURRENT_USER_ID], '#27ae60',
                                '#c0392b'
                            ],
                            'line-width': ['interpolate', ['linear'], ['zoom'], 10, 3, 15, 6],
                            'line-blur': 6,
                            'line-opacity': 0.25
                        },
                        minzoom: 10
                    });
                }
              })
              .catch(error => console.error('Error fetching flags:', error));
        }

        function updateNearbyPlayers(players) {
            gameState.nearbyPlayers = players;
            
            // Update UI
            const nearbyList = document.getElementById('nearbyPlayersList');
            nearbyList.innerHTML = '';
            
            if (players.length === 0) {
                nearbyList.innerHTML = '<p style="color: #95a5a6; text-align: center;">No players nearby</p>';
                return;
            }
            
            players.forEach(player => {
                const playerElement = document.createElement('div');
                playerElement.className = 'nearby-player';
                playerElement.innerHTML = `
                    <div class="player-info">
                        <div class="player-name">${player.name}</div>
                        <div class="player-level">Level ${player.level}</div>
                    </div>
                    <div class="player-distance">${Math.round(player.distance)}m</div>
                    <div class="action-buttons">
                        <button class="btn btn-combat" onclick="challengePlayer('${player.id}')">Fight</button>
                        <button class="btn btn-trade" onclick="tradeWithPlayer('${player.id}')">Trade</button>
                    </div>
                `;
                nearbyList.appendChild(playerElement);
            });
            
            // Add markers to map
            players.forEach(player => {
                new mapboxgl.Marker({ color: '#e74c3c', scale: 0.8 })
                    .setLngLat([player.lon, player.lat])
                    .setPopup(new mapboxgl.Popup().setHTML(`
                        <strong>${player.name}</strong><br>
                        Level ${player.level}<br>
                        ${Math.round(player.distance)}m away
                    `))
                    .addTo(gameState.map);
            });
        }

        function renderFlagsList() {
            const cont = document.getElementById('flagsList');
            if (!cont) return;
            cont.innerHTML = '';
            const flags = Array.isArray(gameState.flags) ? gameState.flags.slice() : [];
            // Sort by distance
            flags.sort((a, b) => {
                const da = calculateDistance(gameState.character.lat, gameState.character.lon, a.lat, a.lon);
                const db = calculateDistance(gameState.character.lat, gameState.character.lon, b.lat, b.lon);
                return da - db;
            });
            if (!flags.length) {
                cont.innerHTML = '<p style=\"color:#95a5a6; text-align:center;\">No flags nearby</p>';
                return;
            }
            const now = Date.now();
            flags.forEach(f => {
                const dist = Math.round(calculateDistance(gameState.character.lat, gameState.character.lon, f.lat, f.lon));
                const protectS = f.protect_remaining_s != null ? f.protect_remaining_s : (f.protection_ends_at ? Math.max(0, Math.floor((new Date(f.protection_ends_at).getTime() - now)/1000)) : 0);
                const captureS = f.capture_remaining_s != null ? f.capture_remaining_s : (f.capture_window_ends_at ? Math.max(0, Math.floor((new Date(f.capture_window_ends_at).getTime() - now)/1000)) : 0);
                const el = document.createElement('div');
                el.style.cssText = 'background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; gap: 10px;';
                const statusLine = `${f.status}${protectS>0?` ¬∑ Protected ${formatDuration(protectS)}`:''}${captureS>0?` ¬∑ Capture ${formatDuration(captureS)}`:''}`;
                el.innerHTML = `
                    <div style=\"display:flex; flex-direction:column;\">
                      <div style=\"font-weight:600; color:#ecf0f1;\">${(f.name || 'Flag')}</div>
                      <div style=\"font-size: 0.8rem; color:#95a5a6;\">${dist}m ¬∑ ${statusLine} ¬∑ ${f.is_private ? 'Private' : 'Public'}</div>
                    </div>
                    <div style=\"display:flex; gap:6px;\">
                      <button class=\"btn\" style=\"background:#e74c3c;color:white;\" ${(f.is_mine || f.status==='destroyed' || protectS>0 || dist > (window.GAME_CFG.INTERACTION_RANGE_M||30)) ? 'disabled' : ''} onclick=\"attackFlag(gameState.flags.find(x=>x.id==='${f.id}'))\">Attack</button>
                      <button class=\"btn\" style=\"background:#f1c40f;color:black;\" ${(!f.is_mine && f.status==='capturable' && captureS>0 && dist <= (window.GAME_CFG.FLAG_INFLUENCE_RADIUS_M||window.GAME_CFG.CLAIM_INFLUENCE_RADIUS_M||100)) ? '' : 'disabled'} onclick=\"captureFlag(gameState.flags.find(x=>x.id==='${f.id}'))\">Capture</button>
                      <button class=\"btn\" style=\"background:#2ecc71;color:white;\" ${(f.is_mine ? '' : 'disabled')} onclick=\"collectFlag(gameState.flags.find(x=>x.id==='${f.id}'))\">Collect</button>
                      <button class=\"btn\" style=\"background:#2563eb;color:white;\" ${((f.is_mine || !f.is_private) ? '' : 'disabled')} onclick=\"jumpToFlag(gameState.flags.find(x=>x.id==='${f.id}'))\">Jump</button>
                    </div>
                `;
                cont.appendChild(el);
            });
        }

        function npcSlug(name) {
            try {
                return String(name || '')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/(^-|-$)/g, '');
            } catch (_) { return 'npc'; }
        }

        function updateMonsters(monsters) {
            gameState.monsters = monsters;
            
            // Add monster markers to map
            monsters.forEach(monster => {
                const color = getMonsterColor(monster.level);
                const isInRange = monster.distance <= 50; // 50m range for combat
                
                // Create enhanced popup HTML with Fight button
                const popupHTML = `
                    <div class="npc-popup">
                        <div class="npc-header">
                            <strong class="npc-name">${monster.name}</strong>
                            <span class="npc-level">Level ${monster.level}</span>
                        </div>
                        <div class="npc-stats">
                            <div class="npc-hp">
                                <div class="hp-label">HP:</div>
                                <div class="hp-bar-container">
                                    <div class="hp-bar-bg">
                                        <div class="hp-bar-fill" style="width: ${(monster.current_hp / monster.max_hp) * 100}%"></div>
                                    </div>
                                    <div class="hp-text">${monster.current_hp}/${monster.max_hp}</div>
                                </div>
                            </div>
                            <div class="npc-distance">${Math.round(monster.distance)}m away</div>
                        </div>
                        <div class="npc-actions">
                            ${isInRange ? 
                                `<button class="fight-btn" onclick="startAutoCombat('${monster.id}')">‚öîÔ∏è Fight</button>` : 
                                `<button class="fight-btn disabled" disabled>Too Far Away</button>`
                            }
                        </div>
                    </div>
                `;
                
                // Build a custom marker element using themed icon when available
                const slug = npcSlug(monster.name);
                const img = document.createElement('img');
                const mapObj = window.NPC_MARKER_URLS || {};
                const mapped = mapObj[slug] || mapObj.default || null;
                const base = window.NPC_MARKER_BASE || '/static/img/npc/markers/';
                img.width = 28; img.height = 28;
                img.style.filter = 'drop-shadow(0 0 2px rgba(0,0,0,0.6))';
                img.alt = slug;

                // Fallback element (colored circle) if icon missing
                const fallback = document.createElement('div');
                fallback.style.cssText = `width: 16px; height: 16px; border-radius: 50%; background: ${color}; box-shadow: 0 0 4px rgba(0,0,0,0.6);`;

                // Avoid 404 spam: use an <img> when we have a pre-resolved URL; otherwise use a tiny colored circle.
                const useImage = !!mapped;
                if (!mapObj[slug] && mapObj.default) {
                    try { console.warn('NPC marker missing for:', slug, '‚Üí using default'); } catch (_) {}
                }
                if (useImage) { img.src = mapped; }
                const markerEl = useImage ? img : fallback;

                const marker = new mapboxgl.Marker({ element: markerEl, anchor: 'center' });
                if (useImage) { img.onerror = () => { try { marker.setElement(fallback); } catch (_) {} }; }
                marker
                    .setLngLat([monster.lon, monster.lat])
                    .setPopup(new mapboxgl.Popup({ 
                        closeOnClick: true,
                        closeButton: true,
                        maxWidth: '280px'
                    }).setHTML(popupHTML))
                    .addTo(gameState.map);
            });
        }
        
        function getMonsterColor(level) {
            // Color code monsters by level difficulty
            if (level <= 2) return '#32cd32';      // Green for easy (levels 1-2)
            if (level <= 5) return '#ffd700';      // Yellow for moderate (levels 3-5)
            if (level <= 8) return '#ff8c00';      // Orange for hard (levels 6-8)
            return '#dc143c';                       // Red for very hard (level 9+)
        }

        function getResourceEmoji(rt) {
            switch ((rt || '').toLowerCase()) {
                case 'tree': return 'üå≥';
                case 'berry_bush': return 'üçì';
                case 'herb_patch': return 'üåø';
                case 'stone_quarry': return 'ü™®';
                case 'iron_mine': return '‚õèÔ∏è';
                case 'gold_mine': return 'üíé';
                case 'ruins': return 'üè∫';
                case 'cave': return 'üï≥Ô∏è';
                case 'well': return 'üíß';
                case 'farm': return 'üåæ';
                default: return 'üìç';
            }
        }
        function getResourceIconUrl(rt) {
            const k = String(rt || '').toLowerCase();
            const map = (typeof window !== 'undefined' && window.RESOURCE_ICON_URLS) ? window.RESOURCE_ICON_URLS : {};
            return map[k] || null;
        }
        function formatDuration(total) {
            total = Math.max(0, Math.floor(Number(total || 0)));
            const m = Math.floor(total / 60);
            const s = total % 60;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        function updateResourceMarkers(resources) {
            if (!gameState.map) return;
            if (!gameState.resourceMarkers) gameState.resourceMarkers = {};
            const ids = new Set((resources || []).map(r => String(r.id)));
            // Remove missing
            Object.keys(gameState.resourceMarkers).forEach(id => {
                if (!ids.has(id)) {
                    try { gameState.resourceMarkers[id].remove(); } catch(_) {}
                    delete gameState.resourceMarkers[id];
                }
            });
            // Add/update
            (resources || []).forEach(r => {
                const id = String(r.id);
                const existing = gameState.resourceMarkers[id];
                const emoji = getResourceEmoji(r.type || r.resource_type);
                const iconUrl = getResourceIconUrl(r.type || r.resource_type);
                const canHarvest = !!r.can_harvest && (typeof r.distance === 'number' ? r.distance <= 50 : true);
                const readyIn = typeof r.ready_in_seconds === 'number' ? r.ready_in_seconds : 0;
                const readyLine = canHarvest ? '<span style="color:#16a34a;font-weight:600;">Ready</span>' : (readyIn > 0 ? `Ready in ${formatDuration(readyIn)}` : 'Not ready');
                const popupHTML = `
                    <div style=\"font-family:Segoe UI;color:#333;min-width:220px;\">
                        <div style=\"display:flex;align-items:center;gap:8px;margin-bottom:6px;\">
                            <span style=\"font-size:18px;\">${emoji}</span>
                            <strong>${(r.type_display || r.resource_type || 'Resource').toString().replace(/</g,'&lt;')}</strong>
                        </div>
                        <div style=\"font-size:0.85rem;color:#555;margin-bottom:6px;\">
                            Level ${r.level || 1} ¬∑ Qty ${r.quantity ?? '?'} / ${r.max_quantity ?? '?'}<br/>
                            ${typeof r.distance === 'number' ? `${Math.round(r.distance)}m away` : ''}
                            <div style=\"margin-top:4px;color:#6b7280;\">${readyLine}</div>
                        </div>
                        <div style=\"text-align:center;\">
                            <button ${canHarvest ? '' : 'disabled'} class=\"btn\" style=\"background:#16a34a;color:#fff;padding:6px 10px;border-radius:6px;\" onclick=\"harvestResource('${id}')\">Harvest</button>
                        </div>
                    </div>`;
                if (existing) {
                    try { existing.setLngLat([r.lon, r.lat]).setPopup(new mapboxgl.Popup().setHTML(popupHTML)); } catch(_) {}
                } else {
                    let el;
                    if (iconUrl) {
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.width = 20; img.height = 20;
                        img.style.cssText = 'filter: drop-shadow(0 0 2px rgba(0,0,0,0.6));';
                        img.onerror = () => { try { img.replaceWith(document.createTextNode(emoji)); } catch(_) {} };
                        el = document.createElement('div');
                        el.appendChild(img);
                    } else {
                        el = document.createElement('div');
                        el.style.cssText = 'font-size:18px;filter: drop-shadow(0 0 2px rgba(0,0,0,0.6));';
                        el.textContent = emoji;
                    }
                    const marker = new mapboxgl.Marker({ element: el, anchor: 'center' })
                        .setLngLat([r.lon, r.lat])
                        .setPopup(new mapboxgl.Popup({ closeOnClick: true, closeButton: true }).setHTML(popupHTML))
                        .addTo(gameState.map);
                    gameState.resourceMarkers[id] = marker;
                }
            });
        }

        async function harvestResource(resourceId) {
            try {
                const csrf = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
                const res = await fetch('/api/resources/harvest/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf },
                    credentials: 'same-origin',
                    body: JSON.stringify({ resource_id: resourceId })
                });
                const data = await res.json().catch(()=>({success:false}));
                if (!res.ok || data.success === false) {
                    showMessage((data && data.error) || 'Harvest failed', 'error');
                    return;
                }
                const rewards = data.rewards || {};
                const items = Array.isArray(rewards.items) ? rewards.items : [];
                if (items.length) {
                    try { animateItemDrops({ drops: items.map(i => ({ name: i.name, quantity: i.quantity })) }); } catch(_) {}
                }
                // Update local resource snapshot immediately (server also pushes WS event)
                try {
                    if (data.resource && data.resource.id) {
                        const id = String(data.resource.id);
                        const idx = (gameState.resources || []).findIndex(r => String(r.id) === id);
                        if (idx >= 0) {
                            gameState.resources[idx] = Object.assign({}, gameState.resources[idx], data.resource);
                        } else {
                            gameState.resources.push(data.resource);
                        }
                        updateResourceMarkers(gameState.resources);
                        renderResourcesList(gameState.resources);
                    }
                } catch(_) {}
                showMessage('Harvested successfully!', 'success');
                try { loadInventory(); } catch(_) {}
            } catch (e) {
                console.warn('harvestResource error', e);
                showMessage('Harvest failed', 'error');
            }
        }

        function renderResourcesList(resources) {
            const cont = document.getElementById('resourcesList');
            if (!cont) return;
            cont.innerHTML = '';
            const arr = Array.isArray(resources) ? resources.slice() : [];
            if (!arr.length) {
                cont.innerHTML = '<p style=\"color:#95a5a6; text-align:center;\">No resources nearby</p>';
                return;
            }
            arr.sort((a,b) => (a.distance||1e9) - (b.distance||1e9));
            arr.forEach(r => {
                const emoji = getResourceEmoji(r.type || r.resource_type);
                const iconUrl = getResourceIconUrl(r.type || r.resource_type);
                const canHarvest = !!r.can_harvest && (typeof r.distance === 'number' ? r.distance <= 50 : true);
                const readyIn = typeof r.ready_in_seconds === 'number' ? r.ready_in_seconds : 0;
                const readyText = canHarvest ? '<span style="color:#22c55e;">Ready</span>' : (readyIn > 0 ? `Ready in ${formatDuration(readyIn)}` : 'Not ready');
                const el = document.createElement('div');
                el.style.cssText = 'background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; gap: 10px;';
                const iconSpan = iconUrl ? `<img src="${iconUrl}" style="width:18px;height:18px;vertical-align:middle;" onerror="this.replaceWith(document.createTextNode('${emoji}'))">` : `<span style=\"font-size:18px;\">${emoji}</span>`;
                el.innerHTML = `
                    <div style=\"display:flex; align-items:center; gap:8px;\">
                        ${iconSpan}
                        <div style=\"display:flex; flex-direction:column;\">
                            <div style=\"font-weight:600; color:#ecf0f1;\">${(r.type_display || r.resource_type)}</div>
                            <div style=\"font-size: 0.8rem; color:#95a5a6;\">Lvl ${r.level || 1} ¬∑ ${Math.round(r.distance || 0)}m ¬∑ ${r.quantity}/${r.max_quantity} ¬∑ ${readyText}</div>
                        </div>
                    </div>
                    <div>
                        <button class=\"btn\" style=\"background:#16a34a;color:white;\" ${canHarvest ? '' : 'disabled'} onclick=\"harvestResource('${r.id}')\">Harvest</button>
                    </div>`;
                cont.appendChild(el);
            });
        }

        // Territory polygon helpers
        const CELL_DEG = {{ game_settings.FLAG_CELL_DEGREES|default:0.002 }};

        function circlePolygon(lon, lat, radiusMeters, steps = 60) {
            const R = 6378137;
            const d = radiusMeters / R;
            const phi1 = lat * Math.PI / 180;
            const lam1 = lon * Math.PI / 180;
            const coords = [];
            for (let i = 0; i <= steps; i++) {
                const brng = 2 * Math.PI * i / steps;
                const phi2 = Math.asin(Math.sin(phi1) * Math.cos(d) + Math.cos(phi1) * Math.sin(d) * Math.cos(brng));
                const lam2 = lam1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(phi1), Math.cos(d) - Math.sin(phi1) * Math.sin(phi2));
                coords.push([lam2 * 180 / Math.PI, phi2 * 180 / Math.PI]);
            }
            return { type: 'Polygon', coordinates: [coords] };
        }
        // Web Mercator helpers (meters)
        const ORIGIN_SHIFT = 20037508.34;
        function project(lon, lat) {
            const x = lon * ORIGIN_SHIFT / 180;
            let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
            y = y * ORIGIN_SHIFT / 180;
            return [x, y];
        }
        function unproject(x, y) {
            const lon = (x / ORIGIN_SHIFT) * 180;
            let lat = (y / ORIGIN_SHIFT) * 180;
            lat = 180/Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI/2);
            return [lon, lat];
        }

        // ==============================
        // Hex axial utilities (flat-top)
        // ==============================
        function hexConstants() {
            const r = 650; // keep in sync with drawHexGrid()
            const w = 2 * r;
            const h = Math.sqrt(3) * r;
            const xStep = 1.5 * r;
            const yStep = h;
            return { r, w, h, xStep, yStep };
        }
        function latticeOriginMeters() {
            // Anchor to player's current position for stable IDs matching the grid
            const [pX, pY] = project(gameState.character.lon, gameState.character.lat);
            const { xStep, yStep } = hexConstants();
            const originX = Math.floor(pX / xStep) * xStep;
            const originY = Math.floor(pY / yStep) * yStep;
            return { originX, originY };
        }
        // Convert local meters (relative to lattice origin) to axial (q,r) for flat-top
        function axialFromXYFlat(x, y, s) {
            const qf = (2/3) * x / s;
            const rf = (-1/3) * x / s + (Math.sqrt(3)/3) * y / s;
            return { qf, rf };
        }
        function cubeRound(x, y, z) {
            let rx = Math.round(x);
            let ry = Math.round(y);
            let rz = Math.round(z);
            const x_diff = Math.abs(rx - x);
            const y_diff = Math.abs(ry - y);
            const z_diff = Math.abs(rz - z);
            if (x_diff > y_diff && x_diff > z_diff) {
                rx = -ry - rz;
            } else if (y_diff > z_diff) {
                ry = -rx - rz;
            } else {
                rz = -rx - ry;
            }
            return { rx, ry, rz };
        }
        function axialRound(qf, rf) {
            const xf = qf;
            const zf = rf;
            const yf = -xf - zf;
            const { rx, ry, rz } = cubeRound(xf, yf, zf);
            return { q: rx, r: rz };
        }
        function xyFromAxialFlat(q, r, s) {
            const x = s * (1.5 * q);
            const y = s * (Math.sqrt(3) * (r + q/2));
            return { x, y };
        }
        // Axial helpers for ranges/distances
        function axialNeighbors(q, r) {
            // flat-top axial neighbor directions
            return [
                { q: +1, r: 0 }, { q: +1, r: -1 }, { q: 0, r: -1 },
                { q: -1, r: 0 }, { q: -1, r: +1 }, { q: 0, r: +1 }
            ].map(d => ({ q: q + d.q, r: r + d.r }));
        }
        function axialDistance(q1, r1, q2, r2) {
            // cube distance with y = -x - z
            const x1 = q1, z1 = r1, y1 = -x1 - z1;
            const x2 = q2, z2 = r2, y2 = -x2 - z2;
            return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
        }
        function axialRange(q, r, radius) {
            const cells = [];
            for (let dq = -radius; dq <= radius; dq++) {
                for (let dr = Math.max(-radius, -dq - radius); dr <= Math.min(radius, -dq + radius); dr++) {
                    const q2 = q + dq;
                    const r2 = r + dr;
                    cells.push({ q: q2, r: r2 });
                }
            }
            return cells;
        }
        // Public helpers
        function getHexIdForLonLat(lon, lat) {
            const { r } = hexConstants();
            const [xAbs, yAbs] = project(lon, lat);
            const { qf, rf } = axialFromXYFlat(xAbs, yAbs, r);
            const { q, r: rr } = axialRound(qf, rf);
            return { q, r: rr };
        }
        function getCurrentPlayerHexId() {
            return getHexIdForLonLat(gameState.character.lon, gameState.character.lat);
        }
        function getHexCenterLonLat(q, rAxial) {
            const { r } = hexConstants();
            const { x, y } = xyFromAxialFlat(q, rAxial, r);
            return unproject(x, y);
        }

        function flagRadiusForLevel(level) {
            // Derive from hex overlay size to avoid drift
            return hexConstants().r;
        }
        // Fixed number of lattice rings claimed by every flag (0 = just one hex per placement)
        const CLAIM_RADIUS_CELLS = 0;
        function claimCellRadiusForLevel(level) {
            // Fixed radius, ignores level. Change CLAIM_RADIUS_CELLS to adjust globally.
            return CLAIM_RADIUS_CELLS;
        }
        // Territory hex visual radius (meters) for map rendering
        const TERRITORY_HEX_RADIUS_M = hexConstants().r;
        // Keep cellSquarePolygon available for potential debugging overlays
        function cellSquarePolygon(lat, lon, cellDeg = CELL_DEG) {
            const half = cellDeg / 2;
            const minLat = lat - half;
            const maxLat = lat + half;
            const minLon = lon - half;
            const maxLon = lon + half;
            return {
                type: 'Polygon',
                coordinates: [[
                    [minLon, minLat],
                    [maxLon, minLat],
                    [maxLon, maxLat],
                    [minLon, maxLat],
                    [minLon, minLat]
                ]]
            };
        }
        function mercatorHexFromLonLat(lon, lat, radiusMeters) {
            // Build flat-top hex using the SAME Mercator meter math as the grid so edges align perfectly
            const [cx, cy] = project(lon, lat);
            const coords = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i + Math.PI / 6; // flat-top orientation
                const px = cx + radiusMeters * Math.cos(angle);
                const py = cy + radiusMeters * Math.sin(angle);
                coords.push(unproject(px, py));
            }
            coords.push(coords[0]);
            return { type: 'Polygon', coordinates: [coords] };
        }

function buildHexGeo(flags) {
            // One hex per placement (no union). Increase size so adjacent tiles overlap noticeably.
            const tR = hexConstants().r * 1.25; // strong overlap (~25%)
            const features = [];
            (flags || []).forEach(f => {
                // Snap to nearest lattice cell for placement center (already snapped on place, but safe)
                const { q, r: rr } = getHexIdForLonLat(f.lon, f.lat);
                const [lonC, latC] = getHexCenterLonLat(q, rr);
                const poly = mercatorHexFromLonLat(lonC, latC, tR);
                const color = (typeof f.color === 'string' && /^#([0-9a-fA-F]{3}){1,2}$/.test(f.color)) ? f.color : null;
                features.push({
                    type: 'Feature',
                    geometry: poly,
                    properties: { owner_id: f.owner_id, status: f.status || 'active', cell_q: q, cell_r: rr, flag_id: f.id, color: color }
                });
            });
            return { type: 'FeatureCollection', features };
        }

        // Dissolve adjacent hexes by owner/status so regions become single puzzle-like shapes
        function dissolveHexesByOwner(hexFC) {
            try {
                const groups = new Map();
                for (const f of (hexFC?.features || [])) {
                    const owner = (f.properties && f.properties.owner_id != null) ? String(f.properties.owner_id) : 'none';
                    const status = (f.properties && f.properties.status) ? String(f.properties.status) : 'active';
                    const key = owner + '__' + status;
                    if (!groups.has(key)) groups.set(key, []);
                    groups.get(key).push(f);
                }
                const out = [];
                for (const [key, feats] of groups.entries()) {
                    const [owner_id, status] = key.split('__');
                    let dissolvedFeature = null;
                    if (typeof turf !== 'undefined' && feats.length) {
                        // Prefer turf.dissolve when available
                        if (typeof turf.dissolve === 'function') {
                            const fc = { type: 'FeatureCollection', features: feats };
                            const res = turf.dissolve(fc);
                            if (res) {
                                if (res.type === 'FeatureCollection') {
                                    (res.features || []).forEach(g => { g.properties = { owner_id, status }; out.push(g); });
                                    continue;
                                } else if (res.type === 'Feature') {
                                    res.properties = { owner_id, status };
                                    out.push(res);
                                    continue;
                                }
                            }
                        }
                        // Fallback: pairwise union
                        try {
                            dissolvedFeature = feats.reduce((acc, f) => acc ? turf.union(acc, f) : f, null);
                        } catch (e) {
                            // If union fails for complex geometries, just push originals as a last resort
                            dissolvedFeature = null;
                        }
                    }
if (dissolvedFeature) {
                        // Try to propagate a representative color for the group (prefer first with color)
                        let groupColor = null;
                        try {
                            for (const f0 of feats) { const c0 = (f0.properties && f0.properties.color); if (typeof c0 === 'string' && c0) { groupColor = c0; break; } }
                        } catch(_) { groupColor = null; }
                        dissolvedFeature.properties = { owner_id, status, color: groupColor };
                        out.push(dissolvedFeature);
                    } else {
                        // Fallback: push originals (still colored/stacked by owner)
                        feats.forEach(g => { g.properties = { owner_id, status, color: (g.properties && g.properties.color) || null }; out.push(g); });
                    }
                }
                return { type: 'FeatureCollection', features: out };
            } catch (e) {
                // Absolute fallback: return input unchanged
                return hexFC || { type: 'FeatureCollection', features: [] };
            }
        }

        function loadInventory() {
            fetch('/api/rpg/inventory/')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateInventoryUI(data.inventory);
                    }
                })
                .catch(error => console.error('Error loading inventory:', error));
        }

        function getBerriesCount() {
            try {
                const inv = Array.isArray(gameState.inventoryItems) ? gameState.inventoryItems : [];
                const entry = inv.find(e => (e && e.item && String(e.item.name || '').toLowerCase() === 'berries'));
                const qty = entry ? (typeof entry.quantity === 'number' ? entry.quantity : 0) : 0;
                return qty;
            } catch (_) { return 0; }
        }

        function updateHealButtonState() {
            const btn = document.getElementById('heal-berries-btn');
            if (!btn) return;
            const full = (Number(gameState.character.current_hp) >= Number(gameState.character.max_hp));
            const qty = getBerriesCount();
            const shouldDisable = full || qty <= 0;
            btn.disabled = !!shouldDisable;
            btn.title = shouldDisable ? (full ? 'HP is full' : 'No berries') : 'Use a berry to heal 25% HP';
            // Optional: reflect qty in label
            try {
                const base = 'üçì Heal with berries';
                btn.textContent = qty > 0 ? `${base} (x${qty})` : base;
            } catch (_) {}
        }

        async function healWithBerries() {
            try {
                const csrf = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
                const btn = document.getElementById('heal-berries-btn');
                if (btn) btn.disabled = true;

                async function postBerries(url) {
                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf },
                        credentials: 'same-origin'
                    });
                    let data = null;
                    try { data = await res.json(); } catch (_) {}
                    return { res, data, url };
                }

                // Try modern path first, then legacy fallback
                let attempt = await postBerries('/api/inventory/berries/');
                if (attempt.res.status === 404) {
                    attempt = await postBerries('/legacy/api/inventory/berries/');
                }
                const { res, data } = attempt;

                if (!res.ok || !data || data.success === false) {
                    showMessage((data && data.error) || 'Failed to use berries', 'error');
                    return;
                }
                const stats = data.character_stats || {};
                if (typeof stats.current_hp === 'number' && typeof stats.max_hp === 'number') {
                    gameState.character.current_hp = stats.current_hp;
                    gameState.character.max_hp = stats.max_hp;
                }
                if (typeof stats.current_mana === 'number') gameState.character.current_mana = stats.current_mana;
                if (typeof stats.max_mana === 'number') gameState.character.max_mana = stats.max_mana;
                if (typeof stats.current_stamina === 'number') gameState.character.current_stamina = stats.current_stamina;
                if (typeof stats.max_stamina === 'number') gameState.character.max_stamina = stats.max_stamina;
                updateCharacterStats(gameState.character);
                showMessage(data.message || 'Healed with berries!', 'success');
                try { loadInventory(); } catch (_) {}
                updateHealButtonState();
            } catch (e) {
                console.error('healWithBerries error', e);
                showMessage('Failed to use berries', 'error');
            } finally {
                // Re-enable if still applicable
                try { updateHealButtonState(); } catch(_) {}
            }
        }

        function getItemIcon(item) {
            const name = (item?.item?.name || '').toLowerCase();
            const type = (item?.item?.item_type || '').toLowerCase();
            // Simple emoji mapping; can be swapped for images later
            if (/berry|berries/.test(name)) return 'üçì';
            if (type === 'weapon' || /sword|dagger|axe|bow/.test(name)) return 'üó°Ô∏è';
            if (type === 'armor' || /armor|mail|vest|helmet|shield/.test(name)) return 'üõ°Ô∏è';
            if (type === 'consumable' || /potion|food|meat|bread/.test(name)) return 'üß™';
            if (/ore|artifact|gold|iron|stone|rock/.test(name)) return 'ü™®';
            return 'üéí';
        }

        function updateInventoryUI(inventory) {
            const inventoryGrid = document.getElementById('inventoryGrid');
            if (!inventoryGrid) return;
            inventoryGrid.innerHTML = '';
            
            const items = Array.isArray(inventory) ? inventory.slice() : [];
            // Save for UI logic (e.g., heal button state)
            gameState.inventoryItems = items;
            const TOTAL_SLOTS = 20;
            for (let i = 0; i < TOTAL_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                // Take the i-th item (no server-provided slot index yet)
                const entry = items[i];
                if (entry && entry.item) {
                    const icon = getItemIcon(entry);
                    const qty = typeof entry.quantity === 'number' ? entry.quantity : 1;
                    const nm = entry.item.name || 'Item';
                    const desc = entry.item.description || '';
                    const type = (entry.item.item_type || '').toLowerCase();
                    slot.innerHTML = `
                        <div class="item-icon" style="display:flex;align-items:center;justify-content:center;font-size:20px;background:none;">${icon}</div>
                        <div class="item-quantity">${qty}</div>
                    `;
                    slot.title = `${nm}\n${desc}`;
                    if (entry.is_equipped) slot.classList.add('equipped');
                    // Attach equip/unequip toggle for weapon/armor
                    if (type === 'weapon' || type === 'armor') {
                        slot.style.cursor = 'pointer';
                        slot.addEventListener('click', async () => {
                            try {
                                const csrf = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
                                const isEquipped = !!entry.is_equipped;
                                const endpoint = isEquipped ? '/api/rpg/inventory/unequip/' : '/api/rpg/inventory/equip/';
                                const res = await fetch(endpoint, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf },
                                    credentials: 'same-origin',
                                    body: JSON.stringify({ inventory_item_id: entry.id })
                                });
                                const data = await res.json().catch(()=>({success:false}));
                                if (!res.ok || data.success === false) {
                                    showMessage((data && (data.error || data.message)) || 'Equip failed', 'error');
                                } else {
                                    showMessage(isEquipped ? 'Unequipped' : 'Equipped', 'success');
                                    updateCharacterStats(data.character || {});
                                    // Refresh inventory view
                                    loadInventory();
                                }
                            } catch (e) {
                                console.warn('equip/unequip failed', e);
                                showMessage('Equip failed', 'error');
                            }
                        });
                    }
                }
                
                inventoryGrid.appendChild(slot);
            }
            // Update heal button state after inventory render
            try { updateHealButtonState(); } catch (_) {}
        }

        // WebSocket Connection
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/game/`;
            
            gameState.websocket = new WebSocket(wsUrl);
            
            gameState.websocket.onopen = function() {
                console.log('WebSocket connected');
                showMessage('Connected to game server!', 'success');
                // Request a fresh inventory snapshot after connect
                try { loadInventory(); } catch(_) {}
            };
            
            gameState.websocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            // Also listen for inventory/character updates on the simple map UI
            try {
                if (window.GameSocket && typeof window.GameSocket.on === 'function') {
                    window.GameSocket.on('inventory_update', () => { try { loadInventory(); } catch(_) {} });
                    window.GameSocket.on('character_updated', (payload) => {
                        try {
                            const ch = (payload && payload.data) ? {
                                level: payload.data.level,
                                experience: payload.data.experience,
                                experience_to_next: payload.data.experience_to_next,
                                current_hp: payload.data.health,
                                max_hp: payload.data.max_health,
                                current_mana: payload.data.mana,
                                max_mana: payload.data.max_mana,
                                current_stamina: payload.data.stamina,
                                max_stamina: payload.data.max_stamina,
                                gold: payload.data.gold
                            } : null;
                            if (ch) updateCharacterStats(Object.assign({}, gameState.character, ch));
                        } catch(_) {}
                    });
                }
            } catch(_) {}
            
            gameState.websocket.onclose = function() {
                console.log('WebSocket disconnected');
                showMessage('Disconnected from server. Reconnecting...', 'error');
                
                // Reconnect after 3 seconds
                setTimeout(initializeWebSocket, 3000);
            };
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'player_update':
                    updateCharacterStats(data.character);
                    break;
                case 'resource_update':
                    try {
                        const arr = Array.isArray(data.resources) ? data.resources : (data.resource ? [data.resource] : []);
                        if (arr.length) {
                            const byId = new Map((gameState.resources || []).map(r => [String(r.id), r]));
                            arr.forEach(u => {
                                const id = String(u.id);
                                const prev = byId.get(id) || {};
                                byId.set(id, Object.assign({}, prev, u));
                            });
                            gameState.resources = Array.from(byId.values());
                            try { updateResourceMarkers(gameState.resources); } catch(_) {}
                            try { renderResourcesList(gameState.resources); } catch(_) {}
                        }
                    } catch(_) {}
                    break;
                case 'nearby_players':
                    updateNearbyPlayers(data.players);
                    break;
                case 'chat_message':
                    try {
                        const p = data.data || data.payload || {};
                        addChatMessage(p);
                    } catch(_) {}
                    break;
                case 'combat_start':
                    try {
                        const c = data.combat || data.data;
                        if (c) {
                            gameState.activeCombat = c;
                            createHpTicker(c);
                            startAutoLoopForActiveCombat();
                            showMessage('Combat started!', 'error');
                        }
                    } catch (_) {}
                    break;
                case 'combat_update':
                    try {
                        const c = data.combat || data.data;
                        if (c) {
                            gameState.activeCombat = c;
                            updateHpTicker(c);
                        }
                    } catch(_) {}
                    break;
                case 'combat_end':
                    try { stopAutoCombat(); } catch(_) {}
                    showMessage('Combat ended.', 'info');
                    break;
                case 'level_up':
                    showMessage(`Level up! You are now level ${data.level}!`, 'success');
                    updateCharacterStats(data.character);
                    break;
                case 'inventory_update':
                case 'inventory_updated':
                    // Backend signaled inventory changed (e.g., loot drop, harvest, use)
                    try { loadInventory(); } catch (_) {}
                    break;
                case 'character_update':
                case 'character_updated':
                    // Normalize and apply character snapshot for HUD/XP bar updates
                    try {
                        const p = (data && (data.data || data.character)) || {};
                        const ch = {};
                        if (typeof p.level === 'number') ch.level = p.level;
                        if (typeof p.experience === 'number') ch.experience = p.experience;
                        if (typeof p.experience_to_next === 'number') ch.experience_to_next = p.experience_to_next;
                        if (typeof p.health === 'number') ch.current_hp = p.health;
                        if (typeof p.max_health === 'number') ch.max_hp = p.max_health;
                        if (typeof p.mana === 'number') ch.current_mana = p.mana;
                        if (typeof p.max_mana === 'number') ch.max_mana = p.max_mana;
                        if (typeof p.stamina === 'number') ch.current_stamina = p.stamina;
                        if (typeof p.max_stamina === 'number') ch.max_stamina = p.max_stamina;
                        if (typeof p.gold === 'number') ch.gold = p.gold;
                        updateCharacterStats(Object.assign({}, gameState.character, ch));
                        if (gameState.activeCombat) { try { updateHpTicker(gameState.activeCombat); } catch(_){} }
                    } catch (_) {}
                    break;
                case 'character':
                    // Real-time character snapshot from server (already normalized)
                    updateCharacterStats((data && data.data) ? data.data : (data.character || {}));
                    break;
                case 'trade_request':
                    handleTradeRequest(data.trade);
                    break;
                case 'flag_event':
                    // Merge a single-flag update quickly; fallback to refetch
                    try {
                        const fid = data.flag && data.flag.id ? String(data.flag.id) : null;
                        if (fid) {
                            fetch(`/api/flags/${fid}/`).then(r=>r.json()).then(dd => {
                                if (dd && dd.ok && dd.flag) mergeFlagDetail(dd.flag);
                            }).catch(()=>{});
                        } else {
                            fetchNearbyFlags();
                        }
                    } catch (e) { console.warn('flag_event refresh failed', e); }
                    break;
            }
        }

        // Combat System
        function startPvECombat(monsterId) {
            fetch('/api/rpg/combat/pve/start/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({ monster_id: monsterId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    gameState.activeCombat = data.combat;
                    showCombatModal(data.combat);
                } else {
                    showMessage(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error starting combat:', error);
                showMessage('Failed to start combat', 'error');
            });
        }

        async function combatAction(action) {
            if (!gameState.activeCombat) return;
            try {
                const res = await fetch('/api/rpg/combat/action/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({
                        combat_id: gameState.activeCombat.id,
                        action: action
                    })
                });
                const data = await res.json();
                if (data.success) {
            if (data.success) {
                        hideCombatModal();
                        try { if (data.message) addCombatLog(data.message); } catch(_) {}
                        showMessage(data.message, data.victory ? 'success' : 'error');
                        if (data.victory) {
                            try { showVictoryPopup(data); } catch(e) { console.warn('Victory popup error', e); }
                        }
                        gameState.activeCombat = null;
                        // Update character stats
                        updateCharacterStats(data.character);
                        // If defeat, immediately respawn at user's real location
                        if (data.defeat) { try { handleRespawnFlow(); } catch(e) { console.warn('respawn flow failed', e); } }
                        // Refresh game data (also updates inventory)
                        loadGameData();
                        try { stopAutoCombat(); } catch(_) {}
                    } else {
                        try { if (data.message) addCombatLog(data.message); } catch(_) {}
                        // Update UI if modal is open, and always update ticker if present
                        try { updateCombatUI(data.combat); } catch(_) {}
                        try { updateHpTicker(data.combat); } catch(_) {}
                        gameState.activeCombat = data.combat;
                    }
                } else {
                    showMessage(data.error, 'error');
                }
            } catch (error) {
                console.error('Error performing combat action:', error);
                showMessage('Combat action failed', 'error');
            }
        }

        function showCombatModal(combat) {
            // PK-style: do not use modal; use ticker only
            try { createHpTicker(combat); } catch(_) {}
        }

        function hideCombatModal() {
            const modal = document.getElementById('combatModal');
            try { modal.style.display = 'none'; } catch(_) {}
        }

        // Respawn flow: ask browser geolocation, call server, and refresh UI
        async function handleRespawnFlow() {
            function getGeo() {
                return new Promise((resolve) => {
                    if (!navigator.geolocation) return resolve(null);
                    try {
                        navigator.geolocation.getCurrentPosition(
                            (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                            () => resolve(null),
                            { enableHighAccuracy: true, timeout: 4000 }
                        );
                    } catch(_) { resolve(null); }
                });
            }
            const geo = await getGeo();
            const payload = geo ? { lat: geo.lat, lon: geo.lon } : {};
            try {
                const res = await fetch('/api/rpg/character/respawn/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value },
                    body: JSON.stringify(payload)
                });
                const data = await res.json().catch(()=>({success:false}));
                if (!res.ok || !data.success) {
                    showMessage(data.error || 'Respawn failed', 'error');
                    return;
                }
                // Update state and map
                if (data.location) {
                    gameState.character.lat = data.location.lat;
                    gameState.character.lon = data.location.lon;
                    if (playerMarker) playerMarker.setLngLat([gameState.character.lon, gameState.character.lat]);
                    try { gameState.map.setCenter([gameState.character.lon, gameState.character.lat]); } catch(_) {}
                }
                if (data.character) updateCharacterStats(data.character);
                showMessage('Respawned at your current location with full health.', 'success');
                try { loadGameData(); } catch(_) {}
            } catch (e) {
                console.warn('Respawn error', e);
                showMessage('Failed to respawn', 'error');
            }
        }

        // Auto-combat ticker (shows HP bars at top; no modal)
        function createHpTicker(combat) {
            try { removeHpTicker(); } catch(_) {}
            const el = document.createElement('div');
            el.id = 'hp-ticker';
            el.style.cssText = 'position:fixed;top:70px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,0.9);border:1px solid rgba(255,255,255,0.12);padding:8px 12px;border-radius:10px;color:#e5e7eb;z-index:1700;min-width:260px;box-shadow:0 8px 20px rgba(0,0,0,0.4);';
            el.innerHTML = `
                <div style="display:flex;justify-content:space-between;margin-bottom:6px;font-weight:700;">
                    <span id="hpTickPlayerName">${(gameState.character.name || 'You').toString().replace(/</g,'&lt;')}</span>
                    <span id="hpTickEnemyName">${(combat.enemy && combat.enemy.name ? combat.enemy.name : 'Enemy').toString().replace(/</g,'&lt;')}</span>
                </div>
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:4px;">
                    <div style="flex:1;height:8px;background:#374151;border-radius:6px;overflow:hidden;">
                        <div id="hpTickPlayerBar" style="height:100%;background:#ef4444;width:0%"></div>
                    </div>
                    <div id="hpTickPlayerText" style="font-size:12px;min-width:60px;text-align:right;">0/0</div>
                </div>
                <div style="display:flex;gap:8px;align-items:center;">
                    <div style="flex:1;height:8px;background:#374151;border-radius:6px;overflow:hidden;">
                        <div id="hpTickEnemyBar" style="height:100%;background:#f59e0b;width:0%"></div>
                    </div>
                    <div id="hpTickEnemyText" style="font-size:12px;min-width:60px;text-align:right;">0/0</div>
                </div>`;
            document.body.appendChild(el);
            gameState.hpTickerEl = el;
            updateHpTicker(combat);
        }
        function updateHpTicker(combat) {
            const el = gameState.hpTickerEl; if (!el || !combat) return;
            const pMax = Number(gameState.character.max_hp) || 1;
            const pHp = Math.max(0, Math.min(pMax, Number((combat.player_hp != null ? combat.player_hp : gameState.character.current_hp))));
            const eMax = Number((combat.enemy && combat.enemy.max_hp) || combat.enemy_max_hp || 1);
            const eHp = Math.max(0, Math.min(eMax, Number((combat.enemy_hp != null ? combat.enemy_hp : eMax))));
            const pPct = Math.max(0, Math.min(100, (pHp / pMax) * 100));
            const ePct = Math.max(0, Math.min(100, (eHp / eMax) * 100));
            const pb = el.querySelector('#hpTickPlayerBar');
            const pt = el.querySelector('#hpTickPlayerText');
            const eb = el.querySelector('#hpTickEnemyBar');
            const et = el.querySelector('#hpTickEnemyText');
            if (pb) pb.style.width = pPct + '%';
            if (pt) pt.textContent = `${Math.round(pHp)}/${Math.round(pMax)}`;
            if (eb) eb.style.width = ePct + '%';
            if (et) et.textContent = `${Math.round(eHp)}/${Math.round(eMax)}`;
        }
        function removeHpTicker() {
            const el = gameState.hpTickerEl;
            if (el && el.parentNode) { try { el.parentNode.removeChild(el); } catch(_) {} }
            gameState.hpTickerEl = null;
        }
        function startAutoLoopForActiveCombat() {
            if (gameState.autoCombatTimer) { try { clearInterval(gameState.autoCombatTimer); } catch(_) {} gameState.autoCombatTimer = null; }
            gameState.autoCombatBusy = false;
            gameState.autoCombatTimer = setInterval(async () => {
                if (!gameState.activeCombat) { stopAutoCombat(); return; }
                if (gameState.autoCombatBusy) return;
                gameState.autoCombatBusy = true;
                try { await combatAction('attack'); } catch(_) {}
                gameState.autoCombatBusy = false;
            }, 800);
        }

        async function startAutoCombat(monsterId) {
            try {
                const res = await fetch('/api/rpg/combat/pve/start/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({ monster_id: monsterId })
                });
                const data = await res.json();
                if (!data.success) {
                    showMessage(data.error || 'Failed to start combat', 'error');
                    return;
                }
                gameState.activeCombat = data.combat;
                createHpTicker(data.combat);
                try { addCombatLog(`Engaged ${data.combat?.enemy?.name || 'enemy'}`); } catch(_) {}
                if (gameState.autoCombatTimer) { clearInterval(gameState.autoCombatTimer); gameState.autoCombatTimer = null; }
                gameState.autoCombatBusy = false;
                gameState.autoCombatTimer = setInterval(async () => {
                    if (!gameState.activeCombat) { stopAutoCombat(); return; }
                    if (gameState.autoCombatBusy) return;
                    gameState.autoCombatBusy = true;
                    try { await combatAction('attack'); } catch(_) {}
                    gameState.autoCombatBusy = false;
                }, 800);
            } catch (e) {
                console.error('Error starting auto combat:', e);
                showMessage('Failed to start combat', 'error');
            }
        }
        function stopAutoCombat() {
            if (gameState.autoCombatTimer) { try { clearInterval(gameState.autoCombatTimer); } catch(_) {} gameState.autoCombatTimer = null; }
            gameState.autoCombatBusy = false;
            removeHpTicker();
        }

        // Victory popup
        function animateItemDrops(result) {
            const drops = Array.isArray(result.drops) ? result.drops : [];
            if (!drops.length) return;
            // Drop at bottom center of map viewport
            const mapEl = document.getElementById('map');
            const rect = mapEl.getBoundingClientRect();
            const baseX = rect.left + rect.width/2;
            const baseY = rect.top + rect.height/2;
            const spread = 40;
            drops.slice(0, 5).forEach((d, i) => {
                const el = document.createElement('div');
                el.className = 'item-drop';
                const icon = getIconForItem(d.name);
                el.innerHTML = `<img src="${icon}" alt="${d.name}"><div>${(d.name || '').toString().replace(/</g,'&lt;')}</div><div class="item-quantity">x${d.quantity || 1}</div>`;
                el.style.left = (baseX + (i - 2) * spread) + 'px';
                el.style.top = (baseY - 20) + 'px';
                el.style.position = 'fixed';
                document.body.appendChild(el);
                setTimeout(() => { try { el.remove(); } catch(_){} }, 1200);
            });
        }
        function getIconForItem(name) {
            const n = String(name || '').toLowerCase();
            if (/gold/.test(n)) return '/static/img/gold_icon.png';
            if (/silver/.test(n)) return '/static/img/silver_icon.png';
            if (/wood/.test(n)) return '/static/img/wood_icon.png';
            if (/iron/.test(n)) return '/static/img/iron_icon.png';
            if (/stone|rock/.test(n)) return '/static/img/stone_icon.png';
            if (/berries?/.test(n)) return '/static/img/berries_icon.png';
            if (/food|meat|bread/.test(n)) return '/static/img/food_icon.png';
            return '/static/img/loot_icon.png';
        }
        function showVictoryPopup(result) {
            try { animateItemDrops(result); } catch(e) {}
            // Build or reuse modal element
            let modal = document.getElementById('victoryModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'victoryModal';
                modal.className = 'victory-modal';
                document.body.appendChild(modal);
            }
            const drops = Array.isArray(result.drops) ? result.drops : [];
            const gainedGold = typeof result.gold_gained === 'number' ? result.gold_gained : null;
            const gainedXP = typeof result.experience_gained === 'number' ? result.experience_gained : null;
            const dropsHTML = drops.length ? (
                '<div class="drops-list">' + drops.map(d => (
                    `<div class="drop-item"><span>${(d.name || '').toString().replace(/</g,'&lt;')}</span><span>x${d.quantity || 1}</span></div>`
                )).join('') + '</div>'
            ) : '<div class="victory-sub">No items dropped.</div>';
            const territoryRadiusMeters = Math.round(flagRadiusForLevel(1));
            modal.innerHTML = `
                <div class="victory-card">
                    <div class="victory-title">Victory!</div>
                    <div class="victory-sub">${(result.message || 'You defeated the monster.').toString().replace(/\</g,'\u0026lt;')}</div>
                    ${gainedXP !== null || gainedGold !== null ? `<div class="drops-list"><div class="drop-item"><span>Experience</span><span>+${gainedXP ?? 0}</span></div><div class="drop-item"><span>Gold</span><span>+${gainedGold ?? 0}</span></div></div>` : ''}
                    ${dropsHTML}
                    <div class="victory-actions">
                        <button class="btn btn-inventory" id="victoryInventoryBtn">Open Inventory</button>
                        <button class="btn btn-close-victory" id="victoryCloseBtn">Close</button>
                    </div>
                </div>`;
            modal.style.display = 'flex';
            const close = () => { modal.style.display = 'none'; };
            modal.addEventListener('click', (e) => { if (e.target === modal) close(); });
            document.getElementById('victoryCloseBtn').onclick = close;
            // Auto-dismiss after 5 seconds
            setTimeout(close, 5000);
            document.getElementById('victoryInventoryBtn').onclick = () => {
                // Switch to inventory tab and refresh
                try { showTab('inventory'); } catch(_) {}
                try { loadInventory(); } catch(_) {}
                close();
            };
        }

        function updateCombatUI(combat) {
            document.getElementById('enemyName').textContent = combat.enemy.name;
            document.getElementById('playerHp').textContent = `${combat.player_hp}/${gameState.character.max_hp}`;
            document.getElementById('enemyHp').textContent = `${combat.enemy_hp}/${combat.enemy.max_hp}`;
            
            const playerHpPercent = (combat.player_hp / gameState.character.max_hp) * 100;
            const enemyHpPercent = (combat.enemy_hp / combat.enemy.max_hp) * 100;
            
            document.getElementById('playerHpBar').style.width = playerHpPercent + '%';
            document.getElementById('enemyHpBar').style.width = enemyHpPercent + '%';
        }

        // Trading System
        function tradeWithPlayer(playerId) {
            // Implement trading UI
            showMessage('Trading system coming soon!', 'info');
        }

        // PvP System
        function challengePlayer(playerId) {
            fetch('/api/rpg/pvp/challenge/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({ player_id: playerId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage('Challenge sent!', 'success');
                } else {
                    showMessage(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error sending challenge:', error);
                showMessage('Failed to send challenge', 'error');
            });
        }

        // UI Functions
        function showTab(tabName, el = null) {
            // Hide all tabs
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab
            const panel = document.getElementById(tabName + '-tab');
            if (panel) panel.classList.add('active');
            
            // Activate the clicked button if provided; otherwise try to find a matching button
            if (el && el.classList) {
                el.classList.add('active');
            } else {
                try {
                    const btn = Array.from(document.querySelectorAll('.tab-button')).find(b => {
                        const onclick = (b.getAttribute('onclick') || '');
                        return onclick.indexOf("showTab('" + tabName + "'") !== -1;
                    });
                    if (btn) btn.classList.add('active');
                } catch(_) {}
            }
        }

        function toggleSidePanel() {
            const panel = document.getElementById('sidePanel');
            panel.classList.toggle('open');
        }

        function showMessage(text, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            
            messageArea.appendChild(message);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                message.remove();
            }, 5000);
        }

        // Chat UI
        function initChatUI() {
            const input = document.getElementById('chatInput');
            if (!input) return;
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
            });
        }
        function toggleChat() {
            const el = document.getElementById('chatOverlay');
            if (!el) return;
            const body = el.querySelector('.chat-body');
            const inputRow = el.querySelector('.chat-input');
            if (el.style.height === '28px') {
                el.style.height = '';
                if (body) body.style.display = '';
                if (inputRow) inputRow.style.display = '';
            } else {
                el.style.height = '28px';
                if (body) body.style.display = 'none';
                if (inputRow) inputRow.style.display = 'none';
            }
        }
        function addChatMessage(p) {
            try {
                const body = document.getElementById('chatMessages');
                if (!body) return;
                const who = (p.character_name || 'Unknown').toString().replace(/</g,'&lt;');
                const ch = (p.channel || 'global');
                const msg = (p.message || '').toString().replace(/</g,'&lt;');
                const t = (p.timestamp || '').toString();
                const row = document.createElement('div');
                row.className = 'chat-msg';
                row.innerHTML = `<span class="chat-meta">[${ch}] ${who}</span> ${msg}`;
                body.appendChild(row);
                body.scrollTop = body.scrollHeight;
            } catch(_) {}
        }
        function sendChat() {
            try {
                const input = document.getElementById('chatInput');
                const sel = document.getElementById('chatChannelSelect');
                const text = (input && input.value ? input.value.trim() : '');
                const channel = (sel && sel.value) || 'location';
                if (!text) return;
                if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                    gameState.websocket.send(JSON.stringify({ type: 'chat', data: { message: text, channel: channel } }));
                }
                input.value = '';
            } catch(_) {}
        }

        // Combat log helpers
        function renderCombatLog() {
            const cont = document.getElementById('combatLogList');
            if (!cont) return;
            const items = gameState.combatLog || [];
            cont.innerHTML = items.slice(-50).map(msg => `<div style="padding:4px 0;border-bottom:1px dashed rgba(255,255,255,0.08);">${(msg || '').toString().replace(/</g,'&lt;')}</div>`).join('');
        }
        function addCombatLog(msg) {
            try {
                if (!gameState.combatLog) gameState.combatLog = [];
                if (msg) gameState.combatLog.push(String(msg));
                renderCombatLog();
            } catch (_) {}
        }

        function updateCharacterStats(character) {
            // Update character object
            Object.assign(gameState.character, character);
            
            // Update UI elements
            const hpBar = document.querySelector('.hp-bar');
            const manaBar = document.querySelector('.mana-bar');
            const staminaBar = document.querySelector('.stamina-bar');
            
            if (hpBar && character.max_hp) hpBar.style.width = (character.current_hp / character.max_hp * 100) + '%';
            if (manaBar && character.max_mana) manaBar.style.width = (character.current_mana / character.max_mana * 100) + '%';
            if (staminaBar && character.max_stamina) staminaBar.style.width = (character.current_stamina / character.max_stamina * 100) + '%';
            
            // Update XP bar if provided
            if (typeof character.experience === 'number' && typeof character.experience_to_next === 'number') {
                const xpBar = document.getElementById('xpBar');
                const xpText = document.getElementById('xpText');
                const toNext = Math.max(1, character.experience_to_next);
                const pct = Math.max(0, Math.min(100, (character.experience / toNext) * 100));
                if (xpBar) xpBar.style.width = pct + '%';
                if (xpText) xpText.textContent = `${character.experience}/${character.experience_to_next}`;
            }
            
            // Update text displays
            const lvlEl = document.querySelector('.level-display');
            const goldEl = document.querySelector('.gold-display');
            if (lvlEl) lvlEl.textContent = `Level ${character.level}`;
            if (goldEl) goldEl.textContent = `${character.gold}g`;
            try { updateHealButtonState(); } catch (_) {}
        }

        function startGameLoop() {
            // Update game state every 5 seconds (keep resources as a fallback refresh)
            setInterval(() => {
                fetchNearbyPlayers();
                fetchNearbyMonsters();
                fetchNearbyResources();
            }, 5000);
        }

        function startResourceTicker() {
            if (gameState.resourceTicker) { try { clearInterval(gameState.resourceTicker); } catch(_) {} }
            gameState.resourceTicker = setInterval(() => {
                let changed = false;
                const arr = Array.isArray(gameState.resources) ? gameState.resources : [];
                for (let i = 0; i < arr.length; i++) {
                    const r = arr[i];
                    if (typeof r.ready_in_seconds === 'number' && r.ready_in_seconds > 0) {
                        r.ready_in_seconds = Math.max(0, r.ready_in_seconds - 1);
                        if (r.ready_in_seconds === 0) {
                            // Optimistically enable harvest; server will validate on click
                            r.can_harvest = true;
                        }
                        changed = true;
                    }
                }
                if (changed) {
                    try { renderResourcesList(arr); } catch(_) {}
                }
            }, 1000);
        }

        // Mobile responsiveness
        function checkMobile() {
            const mobileToggle = document.querySelector('.mobile-menu-toggle');
            if (window.innerWidth <= 768) {
                mobileToggle.style.display = 'block';
            } else {
                mobileToggle.style.display = 'none';
                document.getElementById('sidePanel').classList.remove('open');
            }
        }

        // Tap-to-move system
        let isMoving = false;
        let playerMarker = null;
        
        function initializeTapToMove() {
            // Add click event listener to the map
            gameState.map.on('click', function(e) {
                // Allow movement during combat. If in combat, NPC will follow until leash limit.
                // Don't move if already moving
                if (isMoving) {
                    showMessage('Already moving...', 'info');
                    return;
                }
                
                // Get the clicked coordinates
                const clickLngLat = e.lngLat;
                const targetLat = clickLngLat.lat;
                const targetLon = clickLngLat.lng;
                
                // Perform movement with smooth sliding
                moveCharacterTo(targetLat, targetLon);
            });
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Calculate distance in meters using Haversine formula
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }
        
        async function moveCharacterTo(targetLat, targetLon) {
            if (isMoving) return;
            isMoving = true;
            const startLat = gameState.character.lat;
            const startLon = gameState.character.lon;
            const distance = calculateDistance(startLat, startLon, targetLat, targetLon);
            console.log(`Move requested: ${Math.round(distance)}m`);
            const baseDuration = Math.min(Math.max(distance * 10, 1000), 5000);

            // Ask server first to validate and perform move (enforces territory rules)
            try {
                const res = await fetch('/api/rpg/character/move/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({ lat: targetLat, lon: targetLon })
                });
                const data = await res.json().catch(() => ({ success: false, error: 'Invalid server response' }));
                if (!res.ok || !data.success) {
                    // Server denied the move; keep player at current location
                    showMessage(data.error || 'Move denied by server', 'error');
                    isMoving = false;
                    return;
                }

                // Server accepted and already updated position; animate client to match
                showMessage(`Moving ${Math.round(distance)}m...`, 'info');
                animateMarkerMovement(startLat, startLon, data.lat ?? targetLat, data.lon ?? targetLon, baseDuration);
                const currentZoom = Math.max(16, Math.min(17.5, (gameState.map && typeof gameState.map.getZoom === 'function') ? gameState.map.getZoom() : 17.5));
                gameState.map.easeTo({ center: [data.lon ?? targetLon, data.lat ?? targetLat], zoom: currentZoom, duration: baseDuration });

                // Inform WebSocket to update geo tile subscription (server will move us to the correct tile group)
                try {
                    if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                        gameState.websocket.send(JSON.stringify({
                            type: 'player_movement',
                            lat: data.lat ?? targetLat,
                            lon: data.lon ?? targetLon
                        }));
                    }
                } catch (e) { console.warn('WS move notify failed', e); }

                setTimeout(() => {
                    gameState.character.lat = data.lat ?? targetLat;
                    gameState.character.lon = data.lon ?? targetLon;
                    if (playerMarker) playerMarker.setLngLat([gameState.character.lon, gameState.character.lat]);

                    // Notify via websocket (optional)
                    if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                        gameState.websocket.send(JSON.stringify({ type: 'player_movement', lat: gameState.character.lat, lon: gameState.character.lon }));
                    }

                    isMoving = false;
                    // Auto-open combat if started
                    if (data.combat_started && data.combat) {
                        gameState.activeCombat = data.combat;
                        createHpTicker(gameState.activeCombat);
                        startAutoLoopForActiveCombat();
                        showMessage('An aggressive monster attacks!', 'error');
                    } else {
                        // If combat ended due to leash escape, clear active combat and ticker
                        if (gameState.activeCombat && data.combat_ended && data.fled) {
                            try { stopAutoCombat(); } catch(_) {}
                            gameState.activeCombat = null;
                            showMessage('You escaped the enemy.', 'success');
                        } else {
                            showMessage('Arrived!', 'success');
                        }
                    }
                    loadGameData();
                    checkTerritoryPresence();
                }, baseDuration);
            } catch (e) {
                console.error('Move error:', e);
                showMessage('Failed to move (network error)', 'error');
                isMoving = false;
            }
        }
        
        function animateMarkerMovement(startLat, startLon, targetLat, targetLon, duration) {
            const startTime = performance.now();
            const latDiff = targetLat - startLat;
            const lonDiff = targetLon - startLon;
            
            function updateMarkerPosition(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = easeInOutCubic(progress);
                
                // Calculate current position
                const currentLat = startLat + (latDiff * easedProgress);
                const currentLon = startLon + (lonDiff * easedProgress);
                
                // Update marker position
                if (playerMarker) {
                    playerMarker.setLngLat([currentLon, currentLat]);
                }
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(updateMarkerPosition);
                }
            }
            
            // Start the animation
            requestAnimationFrame(updateMarkerPosition);
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function isInsideFlag(flag, lat, lon) {
            // Presence by hex cell: inside if your current hex matches the flag's hex
            const myCell = getHexIdForLonLat(lon, lat);
            const flagCell = getHexIdForLonLat(flag.lon, flag.lat);
            return myCell.q === flagCell.q && myCell.r === flagCell.r;
        }

        let lastTerritoryOwner = null; // track territory transitions

        function checkTerritoryPresence() {
            const me = { lat: gameState.character.lat, lon: gameState.character.lon };
            const here = (gameState.flags || []).find(f => isInsideFlag(f, me.lat, me.lon));
            const owner = here ? here.owner_id : null;
            if (owner !== lastTerritoryOwner) {
                lastTerritoryOwner = owner;
                if (here) {
                    if (owner === CURRENT_USER_ID) {
                        showMessage('You entered your territory', 'success');
                    } else {
                        showMessage('Enemy territory ‚Äî PvP rules apply!', 'error');
                    }
                } else {
                    showMessage('You left all territories', 'info');
                }
            }
        }

        function updateCharacterPosition(lat, lon) {
            // Deprecated by moveCharacterTo() server-first validation flow.
            // Kept for compatibility if called elsewhere; now behaves as a no-op wrapper.
            return fetch('/api/rpg/character/move/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({ lat, lon })
            }).then(r => r.json()).then(data => {
                if (!data.success) {
                    showMessage(data.error || 'Failed to update position on server', 'error');
                }
                return data;
            }).catch(err => {
                console.error('Error updating position:', err);
                showMessage('Error updating position', 'error');
            });
        }
        
        // Update addPlayerMarker to store reference
        function addPlayerMarker() {
            // Add player location marker
            playerMarker = new mapboxgl.Marker({
                color: '#3498db',
                scale: 1.2
            })
            .setLngLat([gameState.character.lon, gameState.character.lat])
            .addTo(gameState.map);
        }

        // Initialize everything when page loads
window.addEventListener('load', function() {
            initializeMap();
            try { initChatUI(); } catch(_) {}
            try { updateHealButtonState(); } catch (_) {}
            try { renderCombatLog(); } catch(_) {}
            checkMobile();
            // Resume combat if active
            fetch('/api/rpg/combat/state/')
              .then(r => r.json())
              .then(s => {
                if (s && s.success && s.active && s.combat) {
                  gameState.activeCombat = s.combat;
                  createHpTicker(s.combat);
                  startAutoLoopForActiveCombat();
                  showMessage('Resumed active combat.', 'info');
                }
              })
              .catch(() => {});
        });

        window.addEventListener('resize', checkMobile);
        
        // Settings Modal Functions
        function openSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'flex';
        }
        
        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
        }
        
        function openRelocateModal() {
            closeSettingsModal();
            const modal = document.getElementById('relocateModal');
            
            // Update current location display
            const currentDisplay = document.getElementById('currentLocationDisplay');
            currentDisplay.textContent = `${gameState.character.lat.toFixed(6)}, ${gameState.character.lon.toFixed(6)}`;
            
            // Pre-fill inputs with current location
            document.getElementById('newLatitude').value = gameState.character.lat.toFixed(6);
            document.getElementById('newLongitude').value = gameState.character.lon.toFixed(6);
            
            modal.style.display = 'flex';
        }
        
        function closeRelocateModal() {
            const modal = document.getElementById('relocateModal');
            modal.style.display = 'none';
        }
        
        function performRelocate() {
            const newLat = parseFloat(document.getElementById('newLatitude').value);
            const newLon = parseFloat(document.getElementById('newLongitude').value);
            
            // Validate coordinates
            if (isNaN(newLat) || isNaN(newLon)) {
                showMessage('Invalid coordinates entered!', 'error');
                return;
            }
            
            if (newLat < -90 || newLat > 90) {
                showMessage('Latitude must be between -90 and 90', 'error');
                return;
            }
            
            if (newLon < -180 || newLon > 180) {
                showMessage('Longitude must be between -180 and 180', 'error');
                return;
            }
            
            // Calculate distance for user confirmation
            const distance = calculateDistance(
                gameState.character.lat, 
                gameState.character.lon, 
                newLat, 
                newLon
            );
            
            const distanceKm = (distance / 1000).toFixed(2);
            
            if (distance > 100000) { // 100km
                if (!confirm(`You are about to teleport ${distanceKm}km away! Are you sure?`)) {
                    return;
                }
            }
            
            // Show loading message
            showMessage('Teleporting...', 'info');
            
            // Perform the relocation via API
            fetch('/api/rpg/character/relocate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({ lat: newLat, lon: newLon })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update game state
                    gameState.character.lat = data.location.lat;
                    gameState.character.lon = data.location.lon;
                    
                    // Update map center and player marker
                    gameState.map.setCenter([data.location.lon, data.location.lat]);
                    if (playerMarker) {
                        playerMarker.setLngLat([data.location.lon, data.location.lat]);
                    }
                    
                    // Close modal and show success message
                    closeRelocateModal();
                    showMessage(`Teleported ${(data.distance_moved / 1000).toFixed(2)}km! Welcome to your new location.`, 'success');
                    
                    // Refresh nearby data
                    loadGameData();
                } else {
                    showMessage(data.error || 'Failed to relocate character', 'error');
                }
            })
            .catch(error => {
                console.error('Error relocating character:', error);
                showMessage('Failed to teleport. Please try again.', 'error');
            });
        }
        
        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                // Redirect to logout URL
                window.location.href = '/logout/';
            }
        }
        
        // Add CSRF token to all requests
        document.addEventListener('DOMContentLoaded', function() {
            const csrfToken = '{{ csrf_token }}';
            const meta = document.createElement('meta');
            meta.name = 'csrf-token';
            meta.content = csrfToken;
            document.getElementsByTagName('head')[0].appendChild(meta);
            
            // Also add as hidden input for forms
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'csrfmiddlewaretoken';
            input.value = csrfToken;
            document.body.appendChild(input);
        });
        
        // ============================================
        // FLAG SYSTEM INTEGRATION
        // ============================================
        
        // Simple test to check right-click detection
        console.log('üö© Flag system starting...');
        // Global territory radius constant for the placement dialog
        var territoryRadiusMeters = Math.round(flagRadiusForLevel(1));
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üö© DOM ready, setting up flag system');
            
            // Test if we can find the map element
            const mapElement = document.getElementById('map');
            console.log('üö© Found map element:', mapElement);
            
            // Add right-click detector to the map
            if (mapElement) {
                mapElement.addEventListener('contextmenu', function(e) {
                    console.log('üö© Right-click detected on map!');
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Show flag placement dialog
                    showFlagPlacementDialog(e.clientX, e.clientY);
                    return false;
                });
                
                console.log('üö© Right-click listener added to map');
            } else {
                console.error('üö© Could not find map element');
            }
        });
        
        function showFlagPlacementDialog(x, y) {
            // Convert screen coordinates to map coordinates
            const pt = gameState.map.unproject([x, y]);
            const lat = pt.lat;
            const lng = pt.lng;
            
            // Create modal dialog
            const modal = document.createElement('div');
            modal.className = 'flag-placement-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 20000;
            `;
            
            modal.innerHTML = `
                <div style="background: #2d3748; border-radius: 12px; padding: 20px; max-width: 400px; width: 90%; color: white;">
                    <h3 style="margin: 0 0 20px 0; color: #f7fafc;">üö© Place New Flag</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #a0aec0;">Flag Name:</label>
                        <input type="text" id="flag-name" value="My Flag" maxlength="20" 
                               style="width: 100%; padding: 8px; border: none; border-radius: 4px; background: #4a5568; color: white;">
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 10px; background: #4a5568; border-radius: 4px; font-size: 14px;">
                        <strong>Cost:</strong> 500 gold, 20 wood, 10 stone<br>
                        <strong>Location:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <strong>Territory Radius:</strong> ${territoryRadiusMeters} meters<br>
                        <em>Your flag will use your chosen account color</em>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="flag-cancel" style="padding: 10px 20px; background: #718096; border: none; border-radius: 4px; color: white; cursor: pointer;">
                            Cancel
                        </button>
                        <button id="flag-place" style="padding: 10px 20px; background: #38a169; border: none; border-radius: 4px; color: white; cursor: pointer;">
                            Place Flag
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Handle buttons
            modal.querySelector('#flag-cancel').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            modal.querySelector('#flag-place').addEventListener('click', () => {
                const name = modal.querySelector('#flag-name').value.trim() || 'My Flag';
                // Snap the desired placement to nearest lattice cell center before sending to server
                const { q, r } = getHexIdForLonLat(lng, lat);
                const [snappedLon, snappedLat] = getHexCenterLonLat(q, r);
                document.body.removeChild(modal);
                placeFlag(snappedLat, snappedLon, name);
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        function snapToGrid(lat, lon, cellDeg = CELL_DEG) {
            // Snap to nearest grid cell center
            const latIdx = Math.round(lat / cellDeg);
            const lonIdx = Math.round(lon / cellDeg);
            return { lat: latIdx * cellDeg, lon: lonIdx * cellDeg };
        }

        function sameGridCell(a, b, cellDeg = CELL_DEG) {
            const A = snapToGrid(a.lat, a.lon, cellDeg);
            const B = snapToGrid(b.lat, b.lon, cellDeg);
            return A.lat === B.lat && A.lon === B.lon;
        }

        async function placeFlag(lat, lng, name) {
            try {
                console.log(`üö© Placing flag \"${name}\" at ${lat}, ${lng}`);

                // Let the server handle PK-style placement and overlap checks.
                // We still send the clicked coords to provide direction.

                const response = await fetch('/api/flags/place/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        lat: lat,
                        lon: lng,
                        name: name,
                        flag_type: 'territory'
                    })
                });
                if (!response.ok) {
                    // Try to parse error JSON, else show text
                    let msg = 'Failed to place flag.';
                    try { const err = await response.json(); msg = err.error || msg; } catch(e) { try { msg = await response.text(); } catch(_) {} }
                    console.error('‚ùå Flag create failed:', msg);
                    showMessage(msg, 'error');
                    return;
                }
                const data = await response.json();
                if (!data.success) {
                    console.error('‚ùå Flag create failed:', data.error);
                    showMessage(data.error || 'Failed to place flag.', 'error');
                    return;
                }
                const f = data.data;
                const flag = {
                    id: f.id,
                    name: f.name || name,
                    lat: f.lat,
                    lon: f.lon,
                    level: f.level || 1,
                    owner_id: f.owner_id,
                    is_mine: f.owner_id === CURRENT_USER_ID,
                    status: f.status || 'active',
                    uncollected_balance: f.uncollected_balance || 0,
                    is_private: !!f.is_private
                };
                console.log('üö© Flag placed successfully:', flag);
                showMessage(`Flag \"${flag.name}\" placed!`, 'success');
                gameState.flags.push(flag);
                addFlagToMap(flag);

                // Update hex overlay in real-time
                const hexData = buildHexGeo(gameState.flags);
                if (gameState.map.getSource('hex_source')) {
                    gameState.map.getSource('hex_source').setData(hexData);
                } else {
                    // If hex source/layers not initialized yet, fall back to a full refresh
                    try { fetchNearbyFlags(); } catch(_) {}
                }
            } catch (error) {
                console.error('‚ùå Error placing flag:', error);
                showMessage('Failed to place flag. Please try again.', 'error');
            }
        }
        
        function addFlagToMap(flag) {
            // Use owner's chosen color when provided, otherwise default to team/status color
            const chosenColor = (typeof flag.color === 'string' && /^#([0-9a-fA-F]{3}){1,2}$/.test(flag.color)) ? flag.color : null;
            const flagColor = chosenColor || (flag.is_mine ? '#2ecc71' : (flag.status === 'capturable' ? '#f1c40f' : '#ff4444'));
            
            // Create flag marker element using animated GIF
            const flagElement = document.createElement('div');
            flagElement.style.cssText = `
                width: 40px;
                height: 40px;
                cursor: pointer;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            const img = document.createElement('img');
            img.src = FLAG_GIF_URL;
            img.alt = 'Flag';
            img.style.cssText = `
                width: 40px;
                height: 40px;
                object-fit: contain;
                pointer-events: none;
                image-rendering: -webkit-optimize-contrast;
            `;
            // Fallback if image fails to load
            img.onerror = () => {
                try { img.remove(); } catch(e) {}
                const fallback = document.createElement('div');
                fallback.title = 'Flag';
                fallback.style.cssText = `
                    width: 22px; height: 22px; border-left: 3px solid #475569; position: relative;
                `;
                const flagCloth = document.createElement('div');
                flagCloth.style.cssText = `
                    position:absolute; left:3px; top:1px; width:16px; height:10px; background:${flagColor};
                    clip-path: polygon(0 0, 100% 20%, 100% 80%, 0 100%);
                    border:1px solid rgba(0,0,0,0.25);
                `;
                fallback.appendChild(flagCloth);
                flagElement.appendChild(fallback);
            };
            flagElement.appendChild(img);
            
            // Optional: small level badge
            const levelIndicator = document.createElement('div');
            levelIndicator.textContent = flag.level || '1';
            levelIndicator.style.cssText = `
                position: absolute;
                bottom: -2px;
                right: -2px;
                background: ${flagColor};
                color: #fff;
                font-weight: 700;
                font-size: 11px;
                line-height: 1;
                padding: 2px 4px;
                border-radius: 8px;
                box-shadow: 0 1px 2px rgba(0,0,0,0.5);
            `;
            flagElement.appendChild(levelIndicator);

            // Build popup DOM with actions
            const popupEl = document.createElement('div');
            popupEl.style.maxWidth = '280px';
            const isMine = !!flag.is_mine;
            const status = flag.status || 'active';
            const distance = Math.round(calculateDistance(gameState.character.lat, gameState.character.lon, flag.lat, flag.lon));
            const interactM = (window.GAME_CFG && window.GAME_CFG.INTERACTION_RANGE_M) || 30;
            const influenceM = (window.GAME_CFG && (window.GAME_CFG.FLAG_INFLUENCE_RADIUS_M || window.GAME_CFG.CLAIM_INFLUENCE_RADIUS_M)) || 100;
            const nowMs = Date.now();
            const protectS = flag.protect_remaining_s != null ? flag.protect_remaining_s : (flag.protection_ends_at ? Math.max(0, Math.floor((new Date(flag.protection_ends_at).getTime() - nowMs)/1000)) : 0);
            const captureS = flag.capture_remaining_s != null ? flag.capture_remaining_s : (flag.capture_window_ends_at ? Math.max(0, Math.floor((new Date(flag.capture_window_ends_at).getTime() - nowMs)/1000)) : 0);
            let canAttack = !isMine && status !== 'destroyed' && protectS === 0 && distance <= interactM;
            let canCapture = !isMine && status === 'capturable' && captureS > 0 && distance <= influenceM;
            const canCollect = isMine && (flag.uncollected_balance || 0) > 0;
            const canJump = isMine || !flag.is_private; // allow public flags
            const canRun = isMine && status === 'active';
            const extraLines = [];
            if (protectS > 0) extraLines.push(`Protected: ${formatDuration(protectS)}`);
            if (captureS > 0 && status === 'capturable') extraLines.push(`Capture: ${formatDuration(captureS)}`);
            popupEl.innerHTML = `
                <div style=\"font-family: 'Segoe UI', sans-serif;\">
                    <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;\">
                        <strong style=\"font-size:1rem;color:#2c3e50;\">${flag.name || 'Flag'}</strong>
                        <span style=\"font-size:0.8rem;background:${flagColor};color:white;padding:2px 8px;border-radius:12px;\">L${flag.level || 1}</span>
                    </div>
                    <div style=\"font-size:0.85rem;color:#555;margin-bottom:6px;\">
                        Owner: ${isMine ? 'You' : (flag.owner_name || ('#' + (flag.owner_id || '??')))}<br/>
                        Status: ${status.replace('_',' ')}<br/>
                        Dist: ${distance}m${extraLines.length? `<br/>`+extraLines.join(' ¬∑ ') : ''}
                    </div>
                    <div style=\"display:flex;gap:8px;flex-wrap:wrap;\">
                        <button id=\"flag-attack-${flag.id}\" ${canAttack ? '' : 'disabled'} title=\"${protectS>0 ? 'Protected' : (distance>interactM?'Too far':'')}\" style=\"flex:1;padding:6px 10px;background:#e74c3c;color:white;border:none;border-radius:6px;cursor:${canAttack ? 'pointer' : 'not-allowed'};\">Attack</button>
                        <button id=\"flag-capture-${flag.id}\" ${canCapture ? '' : 'disabled'} title=\"${captureS<=0?'No capture window':(distance>influenceM?'Too far':'')}\" style=\"flex:1;padding:6px 10px;background:#f1c40f;color:black;border:none;border-radius:6px;cursor:${canCapture ? 'pointer' : 'not-allowed'};\">Capture</button>
                        <button id=\"flag-collect-${flag.id}\" ${canCollect ? '' : 'disabled'} style=\"flex:1;padding:6px 10px;background:#2ecc71;color:white;border:none;border-radius:6px;cursor:${canCollect ? 'pointer' : 'not-allowed'};\">Collect</button>
                        <button id=\"flag-jump-${flag.id}\" ${canJump ? '' : 'disabled'} style=\"flex:1;padding:6px 10px;background:#2563eb;color:white;border:none;border-radius:6px;cursor:${canJump ? 'pointer' : 'not-allowed'};\">Jump</button>
                        ${isMine ? `<button id=\"flag-privacy-${flag.id}\" style=\"flex:1 1 100%;padding:6px 10px;background:#374151;color:white;border:none;border-radius:6px;\">${flag.is_private ? 'Make Public' : 'Make Private'}</button>` : ''}
                    </div>
                </div>
            `;
            // Attach handlers
            setTimeout(() => {
                const atkBtn = popupEl.querySelector(`#flag-attack-${flag.id}`);
                const capBtn = popupEl.querySelector(`#flag-capture-${flag.id}`);
                const colBtn = popupEl.querySelector(`#flag-collect-${flag.id}`);
                const jmpBtn = popupEl.querySelector(`#flag-jump-${flag.id}`);
                const privBtn = popupEl.querySelector(`#flag-privacy-${flag.id}`);
                if (atkBtn) atkBtn.addEventListener('click', () => attackFlag(flag));
                if (capBtn) capBtn.addEventListener('click', () => captureFlag(flag));
                if (colBtn) colBtn.addEventListener('click', () => collectFlag(flag));
                if (jmpBtn) jmpBtn.addEventListener('click', () => jumpToFlag(flag));
                if (privBtn) privBtn.addEventListener('click', async () => {
                    try {
                        const res = await fetch(`/api/flags/${flag.id}/update/`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '' },
                            credentials: 'same-origin',
                            body: JSON.stringify({ is_private: !flag.is_private })
                        });
                        const data = await res.json();
                        if (!res.ok || data.ok === false) throw new Error(data.error || 'Update failed');
                        showMessage(`Flag is now ${data.flag?.is_private ? 'Private' : 'Public'}`, 'success');
                        try { fetchNearbyFlags(); } catch (_) {}
                    } catch (e) {
                        showMessage(e.message || 'Failed to update privacy', 'error');
                    }
                });
            }, 0);

            // Create Mapbox marker
            const marker = new mapboxgl.Marker({ element: flagElement, anchor: 'center' })
                .setLngLat([flag.lon, flag.lat])
                .setPopup(new mapboxgl.Popup({ closeOnClick: true, closeButton: true }).setDOMContent(popupEl))
                .addTo(gameState.map);
            
            // Save marker so we don't duplicate on refresh
            if (!gameState.flagMarkers) gameState.flagMarkers = {};
            gameState.flagMarkers[flag.id] = marker;
            
            // Shared territory polygons are rendered via territories_source; no per-flag circle.
            return marker;
        }

        
        // Flag actions
        async function attackFlag(flag) {
            try {
                const body = { lat: gameState.character.lat, lon: gameState.character.lon };
                const res = await fetch(`/api/flags/${flag.id}/attack/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '' },
                    credentials: 'same-origin',
                    body: JSON.stringify(body)
                });
                const data = await res.json();
                if (!res.ok || data.ok === false) throw new Error(data.error || 'Attack failed');
                showMessage('Attacked flag!', 'success');
                fetchNearbyFlags();
            } catch (e) {
                showMessage(e.message || 'Attack failed', 'error');
            }
        }
        async function captureFlag(flag) {
            try {
                const body = { lat: gameState.character.lat, lon: gameState.character.lon };
                const res = await fetch(`/api/flags/${flag.id}/capture/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '' },
                    credentials: 'same-origin',
                    body: JSON.stringify(body)
                });
                const data = await res.json();
                if (!res.ok || data.ok === false) throw new Error(data.error || 'Capture failed');
                showMessage('Captured flag!', 'success');
                fetchNearbyFlags();
            } catch (e) {
                showMessage(e.message || 'Capture failed', 'error');
            }
        }
        async function collectFlag(flag) {
            try {
                const res = await fetch(`/api/flags/${flag.id}/collect/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '' },
                    credentials: 'same-origin'
                });
                const data = await res.json();
                if (!res.ok || data.ok === false) throw new Error(data.error || 'Collect failed');
                showMessage(`Collected ${data.result?.collected || 0} gold`, 'success');
                fetchNearbyFlags();
            } catch (e) {
                showMessage(e.message || 'Collect failed', 'error');
            }
        }

        async function jumpToFlag(flag) {
            try {
                const res = await fetch('/api/rpg/character/jump/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ flag_id: flag.id })
                });
                const data = await res.json();
                if (!res.ok || data.success === false) throw new Error(data.error || 'Jump failed');
                // Update state and map
                gameState.character.lat = data.location.lat;
                gameState.character.lon = data.location.lon;
                if (playerMarker) playerMarker.setLngLat([data.location.lon, data.location.lat]);
                gameState.map.setCenter([data.location.lon, data.location.lat]);
                loadGameData();
                showMessage(`Jumped to ${flag.is_private ? 'private (owner)' : 'public'} flag.`, 'success');
            } catch (e) {
                showMessage(e.message || 'Jump failed', 'error');
            }
        }

        function highlightRunCircle(flag) {
            try {
                const id = 'run-active-outline';
                const geom = circlePolygon(flag.lon, flag.lat, flagRadiusForLevel(1), 90);
                const srcData = { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: geom, properties: {} }] };
                if (!gameState.map.getSource('run_active_source')) {
                    gameState.map.addSource('run_active_source', { type: 'geojson', data: srcData });
                } else {
                    gameState.map.getSource('run_active_source').setData(srcData);
                }
                if (!gameState.map.getLayer(id)) {
                    gameState.map.addLayer({ id, type: 'line', source: 'run_active_source', paint: { 'line-color': '#22c55e', 'line-width': 2.5, 'line-opacity': 0.9 } });
                }
                // Put above grid but below flag markers
                try { if (gameState.map.getLayer('territories_border')) gameState.map.moveLayer(id, 'territories_border'); } catch(e){}
            } catch(e) {}
        }

        // Client-side guard: placing flag only if inside own territory
        function isInsideOwnTerritory(lat, lon) {
            return (gameState.flags || []).some(f => f.owner_id === CURRENT_USER_ID && isInsideFlag(f, lat, lon));
        }

        // UI helpers to place flags without right-click
        function showFlagPlacementDialogForLngLat(lng, lat) {
            try {
                if (!gameState.map) return;
                const pt = gameState.map.project({ lng: lng, lat: lat });
                showFlagPlacementDialog(pt.x, pt.y);
            } catch (e) { showMessage('Map not ready', 'error'); }
        }
        function uiPlaceFlagAtCenter() {
            try {
                const c = gameState.map.getCenter();
                showFlagPlacementDialogForLngLat(c.lng, c.lat);
            } catch (e) { showMessage('Map not ready', 'error'); }
        }
        function uiPlaceFlagAtPlayer() {
            try {
                showFlagPlacementDialogForLngLat(gameState.character.lon, gameState.character.lat);
            } catch (e) { showMessage('Map not ready', 'error'); }
        }

        console.log('üö© Flag system loaded');

        // Flag detail fetch & timers
        async function fetchFlagDetails(ids) {
            if (!Array.isArray(ids) || !ids.length) return;
            try {
                await Promise.all(ids.map(async (id) => {
                    try {
                        const res = await fetch(`/api/flags/${id}/`);
                        const d = await res.json();
                        if (d && d.ok && d.flag) mergeFlagDetail(d.flag);
                    } catch (e) {}
                }));
                try { renderFlagsList(); } catch(_) {}
            } catch(_) {}
        }
        function mergeFlagDetail(detail) {
            try {
                const id = String(detail.id);
                const idx = (gameState.flags||[]).findIndex(f => String(f.id) === id);
                if (idx >= 0) {
                    const old = gameState.flags[idx] || {};
                    const merged = Object.assign({}, old, detail || {});
                    // Precompute remaining seconds for UI tickers
                    const now = Date.now();
                    if (merged.protection_ends_at) {
                        merged.protect_remaining_s = Math.max(0, Math.floor((new Date(merged.protection_ends_at).getTime() - now)/1000));
                    }
                    if (merged.capture_window_ends_at) {
                        merged.capture_remaining_s = Math.max(0, Math.floor((new Date(merged.capture_window_ends_at).getTime() - now)/1000));
                    }
                    gameState.flags[idx] = merged;
                }
            } catch(_) {}
        }
        function startFlagTicker() {
            try { if (gameState.flagTicker) clearInterval(gameState.flagTicker); } catch(_) {}
            gameState.flagTicker = setInterval(() => {
                let changed = false;
                (gameState.flags || []).forEach(f => {
                    if (typeof f.protect_remaining_s === 'number' && f.protect_remaining_s > 0) { f.protect_remaining_s = Math.max(0, f.protect_remaining_s - 1); changed = true; }
                    if (typeof f.capture_remaining_s === 'number' && f.capture_remaining_s > 0) { f.capture_remaining_s = Math.max(0, f.capture_remaining_s - 1); changed = true; }
                });
                if (changed) { try { renderFlagsList(); } catch(_) {} }
            }, 1000);
        }

        // Client-side clear of flags and territory layers (non-destructive)
        function resetMapClient() {
            try {
                // Remove flag markers
                if (gameState.flagMarkers) {
                    Object.values(gameState.flagMarkers).forEach(m => { try { m.remove(); } catch(e) {} });
                }
                gameState.flagMarkers = {};
                gameState.flags = [];

                // Remove territory layers and sources
                const layers = ['territories_glow','territories_border','territories_fill','hex_outline','grid-hex-outline','grid-hex'];
                layers.forEach(id => { try { if (gameState.map.getLayer(id)) gameState.map.removeLayer(id); } catch(e) {} });
                const sources = ['territories_source','hex_source','grid'];
                sources.forEach(id => { try { if (gameState.map.getSource(id)) gameState.map.removeSource(id); } catch(e) {} });

                // Redraw hex grid fresh
                try { drawHexGrid(); } catch(e) {}

                showMessage('Map cleared (client-side). Reload or move to fetch fresh data.', 'success');
            } catch (e) {
                console.error('resetMapClient error:', e);
                showMessage('Failed to clear map (client). See console.', 'error');
            }
        }
    </script>
</body>
</html>
